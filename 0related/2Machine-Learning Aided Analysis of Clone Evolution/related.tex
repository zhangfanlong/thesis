\begin{center}{\large\bf 2.\ Related Work}\end{center}

%In recent years, clone research community has increasingly turned its attention to clone management. In general, clone management can be divided into three parts: clone detection, clone analysis and clone maintenance [7,8]. Functionally, clone detection discovers clones in software; clone analysis assists developers in understanding clones, and clone maintenance aims to solve issues arisen from the presence of clones, as well as to make full use of their presence.  

The most popular activity on clones is clone detection. In past decades, researchers have proposed several methods to detect clones, and rolled out a number of effective clone detection tools, such as NiCad [9], CCFinder [10], etc. %According to the technology deployed, these clone detection methods can be classified into different bases: Text, Token, AST, PDG and Metrics. %NiCad is a clone detection method that has been shown to yield both high precision and high recall in near-miss intentional clones. CCFinder can effectively detect clones based on token, and also can effectively identify specific characteristics of software. 
Interested readers can refer to [17] for a detailed review of clone detection based on a comprehensive set of 213 articles. Unfortunately, clone detection alone does not significantly mitigate software maintenance cost. Therefore, clone management issues become increasingly popular in this research community [7,8]. %The most popular clone management activity is clone refactoring. Researchers propose several methods to identify refactoring opportunities and to refactor clones. At the same time, several clone management tools have been built.
JSync [12], a novel clone management tool, which can help developers to manage clone evolution relation and inconsistent change. CloneTracker [18], an Eclipse plug-in, provides support for tracking code clones in evolving software. CeDAR [11], also an Eclipse plug-in, can forward clone detection results to the refactoring engine in Eclipse. 

There is also a significant amount of attention on {\em clone analysis}%., such as clone classification, clone evolution, and clone evaluation. As clone analysis 
, which improves the understanding of clone development and clone impact on software. %, it has been an important research activity since a decade ago. 
Jiachen Yang proposes a classification model that applies machine learning on the judgments made by individual users regarding code clones [15]. Wei Qu proposes a novel pattern mining framework for cloned codes in software systems [16]. % It efficiently exploits software's spatial information as well as graph information and thus can mine accurate patterns of cloned codes for software systems.  
Yun Lin presents an approach to automatically detect differences across multiple clones[24].%; they also have implemented an Eclipse plugin and evaluated its accuracy with respect to three Java software systems .

Code clones evolve with software, and researchers maintain a strong interest in the patterns in which clone changes through software evolution. Kim et al. propose the concept of {\em clone genealogy} to describe evolution, and notice that clone refactoring may not always improve software quality [3]. % because of the following reasons: either a clone may be short lived, or a long-living clone which has changed consistently is usually not easily refactorable. 
Duala-Ekoko proposes a clone tracking system, which produces Clone Region Description for tracking clone evolution, and notifies clone modifications to developers [19]. Bakota presents an approach for mapping code duplications% from one particular version of software to another one. He 
, and proposes a definition of clone smell, which help developers determine clones which show signs related to software defects [20, 21]. Krinke finds that clone code is more stable than non-cloned code, and also older than non-cloned code on average [6]. Bettenburg observes that %only 1.02\%-4.00\% of all clone genealogies introduce software defects at the release level, and suggests that 
clones do not have significant impact on the post-release quality of the studied softwares [13]. Harder finds that clone stability depends on clones' characteristics corresponding to the project environment [22].

There is continuing debate on clone harmfulness. The proponent for clones being harmful holds the view that %the existence of clones can incur additional maintenance effort, and 
clones inconsistently changed during software evolution may lead to software defects[5]. The opponent holds that clones are in general more stable than non-clones during software evolution [6]. Foyzur Rahman %analyzes the relationship between clone and defect proneness. He 
finds that, firstly, a great majority of bugs are not significantly associated with clones. Secondly, clones are less defect prone than non-cloned code [23]. There are also others who adopt a neutral attitude towards the harmfulness of clones. Cory Kapser describes several patterns of clone, and discusses their pros and cons [4]. Some researchers apply Bayesian Networks, a machine-learning technique, to predict the harmfulness of an intended code cloning operation[14]. We take the view, and as shown in the finding in this work, that clones' existence is by nature of the habits taken by developers during software development, and attention paid to consistency in changes in clones during evolution can pay off in mitigating software maintenance effort. 

