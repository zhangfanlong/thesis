% !Mode:: "TeX:UTF-8" 

\BiChapter{基于复制粘贴的克隆代码一致性维护需求预测方法}{Predicting Clone Consistency-Requirement Based on Copy-and-Paste Operation}
%%\BiSection{引言}{Introduction}
\BiSection{摘要}{Abstrct}
在软件开发过程中开发人员往往通过复制粘贴操作复用已有代码，从而产生克隆代码。克隆代码在随系统演化时可能会发生一致性变化。一致性变化往往会导致系统额外的维护代价，同时遗忘一致性变化则会引入相关缺陷，将进一步增大系统的维护代价。本文将由复制粘贴操作产生的克隆代码在其演化过程中所引发的一致性变化，称为克隆代码的一致性维护需求。在复制粘贴时预测克隆代码的一致性维护需求可以有效地降低软件系统的维护代价，从而帮助提高软件质量。鉴于此，本文在定义由复制粘贴操作产生的克隆代码的一致性变化和一致性维护需求的基础上，使用机器学习方法预测克隆代码的一致性维护需求。通过建立和分析系统的克隆家系，收集系统中的所有复制粘贴实例，在此基础上提取代码属性和上线属性两组度量值表示复制粘贴实例，并使用机器学习方法预测克隆代码的一致性维护需求。本文在四个开源软件系统上对本文方法进行评估，实验结果表明本文方法可以在保守和激进两种使用模式下均以较高的准确率和召回率预测克隆代码的一致性维护需求。同时，本文方法可以与软件开发过程相结合，以插件的形式嵌入到集成开发环境中（如eclipse），帮助程序员在软件开发阶段预测克隆代码的一致性维护需求

%%\BiSection{背景与相关知识}{Background and  Related works}
\BiSection{引言}{Introduction}
克隆代码是软件中存在的彼此相似的代码片段(简称克隆)。研究发现通过复制粘贴活动复用已有代码是产生克隆的主要原因\cite{koschke2007survey}。克隆代码会随着软件系统进行演化，为分析其演化过程，Kim等人使用克隆家系描述克隆得演化情况\cite{kim2005empirical}。由于克隆代码彼此之间的相似性，克隆代码在演化过程中会同时发生相似的变化，称为一致性变化。即当某一个克隆片段发生变化时,与之相似的克隆代码往往也需要相同的变化\cite{saha2011automatic}。为确保克隆代码之间的一致性，程序开发人员需要对发生变化的克隆进行一致性维护，从而导致额外的维护代价；而遗忘这种一致性变化，也会导致不一致缺陷而进一步增加软件的维护代价\cite{aversano2007clones}\cite{bettenburg2009empirical}。

克隆代码在产生之时不会发生一致性变化，往往发生在其演化的过程中。本文将在演化过程中由于一致性变化所导致的维护代价称为一致性维护代价。为避免一致性维护代价，程序开发人员需要在复制粘贴时避免可能会发生一致性变化的克隆代码，或者仅允许不会发生一致性变化的克隆代码的产生。因此，在复制粘贴时预测克隆代码在演化过程中是否会发生一致性变化，可帮助避免一致性维护代价。本文将这种克隆代码在其演化过程中是否需要一致性变化称之为一致性维护需求。因此，本文的问题可转化为：\emph{在复制粘贴时对克隆代码进行一致性维护需求的预测问题}。克隆代码的一致性维护需求预测可以帮助降低软件维护代价，并提高软件的质量。

鉴于此，Wang等人基于贝叶斯网络在复制和粘贴时对克隆代码进行一致性维护需求预测，可以帮助避免需要一致性维护的克隆代码\cite{wang2012can}\cite{wang2014predicting}。该方法中提取了历史属性、代码属性和上下文属性等三组属性表示复制和粘贴实例，并使用贝叶斯网络预测克隆代码一致性维护需求。但是，该方法仍在存在以下三点不足：
(1)所使用的克隆一致性变化定义不能完全表示其一致性维护需求。该方法中采用Kim提出的一致性变化定义，将发生变化后仍在一个组的情况定义为一致性变化。该定义仅能处理Type 1和Type 2的克隆代码，无法处理Type 3克隆；(2)所使用的历史属性与复制粘贴操作的关联性较弱，仅表示其所在文件的历史变化情况。同时历史属性也增加了方法与软件开发过程相结合的困难程度(历史属性提取需要软件全部版本源代码)；(3)方法仅使用了贝叶斯网络作为预测模型，并且其实验结果表明在保守模式下可以较好的预测一致性维护需求，但在激进模式下预测结果不够理想。

上述不足限制了该方法的实际应用，无法将其应用到具体的软件开发实践中。为解决上述问题，本文对由于复制粘贴产生的克隆代码的一致性维护需求预测进行了进一步研究，在软件开发过程中实现对其的一致性维护需求预测。首先，本文给出新的一致性变化定义，可更为准确地定义和预测克隆的一致性维护需求。然后，在通过构建克隆家系提取复制和粘贴操作后，舍弃历史属性并扩展了代码属性和上下文属性用于表示复制和粘贴操作。最后，本文除使用贝叶斯网络作为预测模型之外，还分析了其它预测模型在克隆代码一致性需求预测问题上的适用性。

在预测克隆代码的一致性维护需求时，本文有保守模式和激进模式两种使用模式。使用保守模式开发人员可以谨慎的开发软件，通过仅允许不需要一致性维护的复制粘贴操作，从而避免引入会导致额外的克隆代码产生。使用激进模式下开发人员可以快速地开发软件节约开发时间，通过仅阻止需要一致性维护的复制粘贴操作，从而让软件开发人员安全快速的开发软件。本文使用不同的分类器在四个开源软件上进行了实验评估，结果表明本文方法可以同时在保守模式和激进模式下以较高的准确率和召回率对克隆代码进行一致性维护需求预测。本文的主要贡献如下：
(1)本文定义了新的克隆代码一致性变，并根据其定义了克隆代码的一致性维护需求，可以更为准确的标识克隆代码的一致性维护代价；(2)本文使用并扩展代码属性和上下文属性两组属性组，实验结果表明所使用的属性在克隆一致性维护需求的预测中起到了积极的作用；(3)本文预测克隆代码的一致性维护需求，不仅在贝叶斯网络分类器上进行了实验评估，还在一般分类器上进行了实验验证，实验结果表明本文方法具有一般性，可以适用于一般的机器学习方法。

%本文的组织结构如下：第2节是背景知识，介绍了克隆代码的相关概念和克隆演化模型，包括克隆类型、克隆家系和克隆演化模式等。在第3节中详细介绍基于机器学习的克隆代码一致性维护需求预测方法。第4节是本文的实验设置，介绍了评估所选用的系统以及实验评估度量。第5节是实验结果与分析，从两个不同的角度分析和评估本文的实验结果。第6节是相关工作，介绍了克隆代码领域的相关研究。第7节是结论。

\BiSection{背景知识}{Background}
程序开发人员通过复制和粘贴活动产生的克隆代码，依据其文本和功能的相似度，可将克隆代码分成如下四类\cite{roy2009comparison}：
Type 1：除空格、格式和注释外，是完全相同的代码片段。\\
Type 2：除标识符、常量、类型外,是语法结构相同的代码片段。\\
Type 3：拷贝粘贴后修改的代码片段，如改变、增加或删除少量语句的代码,是语法结构相似的代码片段。\\
Type 4：执行相同的功能,但使用不同的语法结构实现的代码片段，是语义相似的代码。

为了检测系统中的克隆代码，研究人员提出和开发了多种克隆检测工具。检测工具往往使用克隆组{\em (Clone Group, CG)}来组织检测到的克隆代码片段{\em (Clone Fragment，CF)}。同一克隆组中的克隆片段之间是彼此相似的，统称为克隆代码。本文使用NiCad检测克隆代码(包含Type 1、Type 2和Type 3克隆代码)，并使用 {\em Unique Percentage Items (UPI)}来计算克隆片段之间的相似度\cite{roy2008nicad}。UPI是两个代码片段之间不同的代码行数占总代码行的比例。给定两个代码片段$CF_1$和$CF_2$，其$UPI(CF_1,CF_2)=0.3$表示两者的差异程度为30\%。同时，其相似度可根据$UPI$计算：$SimText (CF_1,CF_2)=1-UPI=0.7$，表示两者的相似度为70\%。本文在检测克隆代码时，设置克隆代码的相似度阈值为0.7，即相似度大于阈值的代码片段为克隆代码。




为描述克隆代码在系统中随着系统的演化情况，Kim等人提出了克隆家系概念，同时定义了若干种演化模式表示克隆代码的变化\cite{kim2005empirical}。图~\ref{gena2}是克隆家系的示意图，克隆家系可以表示为一个有向无环图。图的根节点是克隆代码产生的节点，通常是由复制和粘贴活动导致。图中连线表示克隆代码在两个版本之间的演化关系。在演化过程中，两个版本间的克隆代码可能会发生变化，使用演化模式描述克隆代码的变化情况。图中给出一个克隆组在五个版本$(V_i~V_{i+4})$中的演化过程。在$V_i$版本，通过复制粘贴活动产生了一个克隆组。从$V_i$到$V_{i+1}$，增加了新克隆代码片段到克隆组中，因此演化模式为增加(克隆组有新的克隆代码片段产生)。从$V_{i+1}$到$V_{i+2}$，克隆组发生了一致性变化模式(克隆组内的克隆代码片段发生相同的变化，克隆片段依然存在同一克隆组中)。从$V_{i+2}$到$V_{i+3}$，克隆组中发生了不一致性变化(克隆组内两个克隆片段发生了不同的变化，仍在一个克隆组内)。从$V_{i+3}$到$V_{i+4}$，克隆组内的克隆片段减少，演化模式为减少。

	在克隆代码的演化过程中，克隆代码的一致性变化问题一直是该领域的研究热点。原因在于克隆代码一致性变化往往会导致额外维护代价，而遗忘这种一致性变化会引发克隆相关的缺陷。然而，研究人员从不同角度对一致性变化有不同的定义。Wang\cite{wang2012can}\cite{wang2014predicting}等人使用Kim的定义\cite{kim2005empirical}，其关注点是克隆发生变化后是否仍在同一克隆组中。同组的克隆代码片段发生变化，若变化后的克隆代码仍在在同一个克隆组中，则称为一致性变化，否则为不一致性变化。
该定义适用于Type 1和Type 2克隆代码，但无法描述变化较大的Type 3克隆。
因此，Saha\cite{saha2011automatic}等人提供了一个更为严格定义，可以处理Type3的克隆代码的变化。其关注点是克隆片段发生相同的变化。同一组内的所有克隆代码都发生相同变化定义为一致性变化，否则称为不一致性变化。该定义更加注重变化本身，要求所有克隆片段发生相似的变化。然而，考虑到所引起的一致性维护代价时，定义又过于严格。例如一克隆组内仅有两个克隆代码发生一致性变化，而其它的克隆代码未发生一致性变化。按照Saha定义该变化为不一致性变化，而这种不一致性变化也会增加维护代价。因此，本文在第3节给出一种新的一致性变化定义，既可以处理Type 3的克隆代码，又可以处理上述仅有两个克隆片段变化的情况。
由复制粘贴产生的克隆代码在演化过程中可能会发生一致性变化，从而导致了克隆的一致性维护代价。本文在复制粘贴之时预测克隆代码的一致性变化，将其称为一致性维护需求。在监测到复制和粘贴操作时（即在克隆代码产生之时），对其进行一致性维护需求预测，可以降低克隆代码的一致性维护代价。

\BiSection {克隆一致性维护需求预测方法}{The Method of Prediction of Clone Consistency-Requirement of Code Clones}

在本节中，主要介绍由复制粘贴所导致的克隆代码的一致性维护需求预测方法。其中，3.1节给出了方法所需的定义。3.2节描述了预测方法的主要框架。3.3和3.4节分别是预测模型的训练和预测阶段。

\BiSubsection{基本定义}{The Definations}

复制粘贴操作是导致克隆代码产生的主要原因，本文假定系统中存在的克隆代码均是由此产生。因此，如何识别系统中的复制粘贴操作是本文研究基础。为解决此问题，本文使用NiCad工具检测系统所有版本中克隆代码，并通过构建克隆家系分析并收集所有的复制粘贴操作。复制粘贴操作也称为复制粘贴实例，其定义如下：


定义1．复制粘贴实例．给定一个克隆组$CG$，其整个演化历史可用克隆家系表示。在表示克隆组$CG$整个演化历史的克隆家系中，第一次出现的克隆组是认为是由复制粘贴活动导致，并称第一次出现的克隆组为复制粘贴实例。


复制粘贴实例即克隆组，随着系统的演化而演化，在此过程中组内的克隆片段可能会发生变化。例如从版本$V_j$演化到$V_j+1$时，其所包含的克隆代码$CF$发生了变化。为了描述这种变化，本文使用$SimText$定义并表示克隆片段的变化，其定义如下：


定义2．克隆变化．在版本$V_j$中存在某一克隆组$CG$， $CF$是$G$中某一克隆片段。当克隆演化到$V_{j+1}$版本时，$CF$在中仍存在该克隆组内，记为$CF'$。本文使用$SimText(CF，CF')$表示克隆片段是否发生变化：若$SimText(CF,CF')<1$，则克隆片段发生变化；若$SimText(CF,CF')=1$，则克隆片段未发生变化。其中$SimText(CF，CF')$计算方法与NiCad相同，使用$UPI$计算其相似度。


克隆组从版本$V_j$演化到$V_j+1$时，组内克隆片段的变化也导致了克隆组的变化，并使用演化模式描述克隆组的变化，称其为一致性变化模式或不一致变化模式（其中一致性变化会产生额外的维护代价）。本文目的是解决由一致性变化导致的一致性维护代价。因此，一致性变化并不需要同组的所有克隆代码片段均需要发生完全一致地变化。假如同组的至少两个克隆代码片段同时发生变化，也会导致一致性维护代价。因此，本文根据克隆组内至少两个克隆片段同时发生变化来定义克隆组的一致性变化模式。在演化中，克隆组一致性变化模式如下所示：


定义3．一致性变化模式．克隆组$CG$从版本$V_j$到$V_j+1$演化为$CG'$。假如$CG$中至少存在两个克隆代码片段$(CF_1,CF_2)$同时发生了变化，记为$(CF'_1,CF'_2)$。如果$CF'_1$和$CF'_2$同时满足$SimText(CF_1,CF'_1)<1$且$SimText(CF_2,CF'_2)<1$，称克隆组$CG$在演化为$CG'$时发生一致性变化模式，反之称为不一致变化模式。


克隆组的一致性变化模式会导致额外的维护代价，而不一致变换模式不会导致额外的维护代价。于此同时，在克隆组整个演化过程中，克隆组可能会发生多次一致性或不一致性变化。尽管如此只要克隆组发生过一致性变化模式，就会引发一致性维护代价。因此，假如我们在复制粘贴时可以预测其在演化过程是否会发生一致性变化模式，则可以通知程序人员避免此复制粘贴活动来避免引入一致性维护代价。据此本文可定义复制粘贴实例的一致性维护需求。在复制粘贴时所预测的克隆一致性变化模式，称为一致性维护需求，其定义如下所示：


定义4．一致性维护需求．给定一个复制粘贴实例（即克隆组），可以用克隆家系描述其整个演化过程。在其演化过程中，该复制粘贴实例至少发生过一次一致性变化模式，则称该实例满足一致性维护需求。


对于一个复制粘贴实例，在其演化过程中发生一致性变化，则认为该实例在未来需要一致性维护，即满足一致性维护需求。因此，本文的研究问题是：{\em 给定一个复制粘贴实例，预测该实例是否满足一致性维护需求}。复制粘贴实例只有两种状态：满足和不满足一致性维护需求。该预测问题可视为一个典型的分类问题，本文使用机器学习模型解决预测分类问题，具体方法见下文。

\BiSubsection{一致性维护需求预测框架}{The Framework of Clone Consistency-Requirement Prediction }

使用机器学习方法预测复制粘贴实例的一致性维护需求，首先需要收集系统中存在的实例，并提取用于表示实例的特征属性。然后，在此基础上构建和训练机器学习模型，预测其一致性维护需求。

\begin{figure}[htbp]
\centering
\includegraphics[width = 0.4\textwidth]{Fig3-2.pdf}
\bicaption[framwork3]{}{基于机器学习的克隆代码一致性维护需求预测框架}{Fig.$\!$}{The Framework of Clone Consistency-Requirement Prediction Based on Machine Learning}\vspace{-1em}
\end{figure}

本文基于机器学习的一致性维护需求预测方法如图~\ref{framwork}~2所示，可分为两个阶段：训练阶段和预测阶段。训练阶段通过收集和分析软件中的复制粘贴实例，生成训练数据集并构建预测器。本文使用克隆检测工具软件中检测克隆代码，并通过构建克隆家系识别复制粘贴实例。然后，提取两组度量值表示该复制粘贴实例，并使用机器学习方法构建和训练预测器。预测阶段通过监测复制粘贴活动，并使用训练好的模型对其进行一致性维护预测。在使用已构建好的模型时，可将该模型嵌入到软件开发环境中。首先在软件开发环境中实时监测复制粘贴操作；然后识别所导致的克隆代码并提取相应度量值；最后将所提取的表示复制粘贴实例的度量值输入到已训练好的机器学习模型中，预测其一致性维护需求。根据预测结果提醒程序开发人员采取进一步的维护和操作。

\BiSubsection{训练阶段}{Trainning Step}

模型训练阶段通过收集复制粘贴实例，构建并训练一致性维护需求的机器学习模型。该阶段可划分为三个子步骤：收集复制粘贴实例、属性提取和模型训练。

\BiSubsubsection{收集复制粘贴实例}{}

根据定义1，本文认为克隆家系中第一次出现的克隆代码是由复制粘贴操作导致。因此，通过检测克隆代码并构建克隆家系完成对系统中复制粘贴实例的收集。首先，下载系统所有版本的源代码，并使用NiCad检测每一版本的克隆代码。使用NiCad的默认配置检测系统中Type 1-3的克隆代码。然后，通过映射所有相邻版本的克隆代码，构建系统中全部克隆家系。为完成版本间的映射，本文使用Clone Region Descriptor(CRD)\cite{duala2010clone}描述克隆代码，包含克隆代码的起始行和上下文信息，如克隆所在文件及方法等。通过CRD所提供的信息映射相邻版本的克隆并生成克隆家系\cite{ci2013new}。最后，通过收集克隆家系中第一次出现的克隆组获取全部的复制粘贴实例。克隆家系是克隆代码演化的有向无环图，图中根节点是由复制粘贴操作形成的克隆代码。通过遍历克隆家系的根节点，可收集系统中所有的复制粘贴实例。

在收集复制粘贴实例后，还需确认该实例中的被复制和被粘贴代码。由于被复制代码会较早地存在软件中，可将克隆代码向历史版本中映射的方式确认。认为被复制代码会存在于上一版本中，被粘贴代码不存在上版本中。根据映射结果，可能会存在两种情况：(1)其中一个克隆代码可以映射，另一个未映射。认为映射代码为被复制代码，未映射为被粘贴代码。(2)两者均没有映射。此情况下随机选取一个为被复制代码，另一个未未被粘贴代码。原因是两者互为克隆代码，彼此之间相似，故随机选取一个为被复制代码并不影响预测结果。注意不存在两者均可映射的情况，应在上一版本检测为克隆代码。

\BiSubsubsection{属性提取}{}
为使用机器学习方法预测复制粘贴实例的一致性维护需求，本文分别提取了两组属性特征表示复制粘贴实例：代码属性和上下文属性。

代码属性是被复制代码的属性，从代码自身角度表示被复制代码，描述被复制代码的词法和语法信息。部分代码属性源于Wang的工作，本文在其基础上进行了扩展，新增Halstead度量属性、结构属性等。Halstead属性经常用于软件预测中，是用于描述代码特征的度量。结构属性是从代码的语法结构信息。具体的代码属性如下所示：
\begin{itemize}
\item 克隆粒度：被复制代码的规模，使用代码行数表示。
\item Halstead度量：被复制代码的代码复杂度，有四个度量值，分别为操作符种类、操作数种类、操作符总量、操作数总量。
\item  结构属性：被复制代码的结构特征，包括if\_then, if\_else, switch, while, do, for, assignment, this\_or\_super等语句的统计。
\item  参数访问数量：被复制代码中所有函数的参数访问数量统计。
\item  总函数调用：被复制代码中所有函数调用的次数统计。
\item  本地函数调用：被复制的代码中，调用函数与被复制片段在相同类的调用次数统计。
\item  库函数调用：被复制的代码中，库函数的调用次数统计，包括java库函数的调用、eclipse库函数的调用以及第三方包函数的调用。
\item  其它调用：被复制的代码中，既不是库函数调用、也不是本地函数调用的其它调用次数统计，如同项目内其它包函数调用、或同包内其它类中的函数调用。
\end{itemize}

上下文属性是被复制和被粘贴代码之间的关系属性，表示两者之间的克隆关系。部分上下文属性来自Wang的工作，同时本文也进行了扩展，新增代码相似度、参数类型相似度和块信息标识等属性。具体的上下文属性如下所示：
\begin{itemize}
\item 	代码相似度：被复制与被粘贴的代码的相似度,使用和NiCad相同的方式计算。
\item 	局部克隆标识：被复制及粘贴的代码片段是否在同一个文件中。
\item 	文件名相似度：被复制和被粘贴代码所在文件的名相似度。假定文件名分别为$M_1$和$M_2$，则文件名相似度为$Sim(M_1,M_2)$，采用李氏距离\cite{levenshtein1966binary}计算(剩余度量中相似度采用相同方法计算)。
\item 	文件名相似度变量：当克隆是局部克隆时，其文件名相似度为1，为非局部克隆时为0。该属性决定文件名相似度是否起效。
\item 	方法名相似度：被复制和被粘贴代码所在方法的方法名字相似度。
\item 	总参数名相似度：假定被复制和被粘贴代码所在方法为$M$和$N$，计算其参数名相似度之和。假设M和N分别包含m和n个参数，即$(P_1,P_2,…,P_m)$和$(Q_1,Q_2,…,Q_n)$，则该度量值为$Sum(Sim(P_i,Q_j))$。
\item 	最大参数名相似度：假定被复制和被粘贴代码所在方法为M和N，其大参数名相似度。假设M和N分别包含m和n个参数，即$(P_1,P_2,…,P_m)$和$(Q_1,Q_2,…,Q_n)$，该度量值为$Max(Sim(P_i,Q_j))$。
\item 	总参数类型相似度：被复制和被粘贴代码所在方法分别为$M$和$N$，其参数类型相似度之和。假设$M$和$N$分别包含$m$和$n$个参数，其参数类型分别为$(P_1,P_2,…,P_m)$和$(Q_1,Q_2,…,Q_n)$,该度量值为$Sum(Sim(P_i,Q_j))$。
\item 	块信息标识：被复制和被粘贴代码的上下文信息是否相同，相同为1，反之为0。
\end{itemize}

\BiSubsubsection{模型训练}{}

提取复制粘贴实例的属性特征后，可进行构建和训练预测模型。本文所采用的机器学习方法为有监督学习方法，因此为还需确认复制粘贴实例的一致性维护需求状态。根据定义4的描述，标记实例的一致性维护需求状态。复制粘贴实例的一致性维护需求状态仅有两种情况:需要一致性维护和不需要一致性维护。为标记其维护状态，可通过遍历克隆家系的演化情况，根据定义4进行标记。通标记维护状态，获得了模型训练的训练数据集，可构建和训练一致性维护需求的预测器。

\BiSubsection{预测阶段}{}

在预测阶段，一致性维护需求预测可和软件开发过程相结合。将训练好的模型嵌入到软件开发环境（如eclipse）中，在复制粘贴时进行预测。需在软件开发环境中监测复制粘贴操作，并使用训练好的预测器对其进行一致性维护需求预测。

\BiSubsubsection{一致性维护预测插件}{}

本文方法可方便的集成于软件开发环境中，如eclipse的插件。在软件开发过程中帮助程序开发人员在预测由复制粘贴产生的克隆代码的一致性维护需求。首先，在软件开发环境中需监测程序员的复制和粘贴操作，识别由此产生的克隆代码。然后，根据上文描述的代码和上下文特征，提取相应的特征表示该复制和粘贴操作。最后，使用训练好的预测器预测该复制粘贴实例的一致性维护需求，将预测器给出的预测结果通知程序开发人员进一步进行处理。

\BiSubsubsection{使用模式}{}

复制粘贴操作有两种状态，分别为需要一致性维护和不需要一致性维护。在使用本文方法进行一致性维护需求预测时，本文可以有两种不同的使用模式，即保守模式和激进模式。

\begin{itemize}
\item 	保守模式：面向不需要一致性维护的复制粘贴实例。在保守模式下，程序员比较谨慎的执行复制和粘贴操作，仅仅允许不需要一致性维护需求的实例的发生，并且会尽量阻止需要一致性维护需求的实例，从而尽量避免引入额外的维护代价。
\item        激进模式：面向需要一致性维护需求的复制粘贴实例。在激进模式下，尽量避免需要一致性维护需求的实例，同时尽量允许不需要一致性维护需求的实例产生，从而节约开发时间。
\end{itemize}

两种不同使用模式可以给程序开发人员不同的选择，从而以适用于不同开发场景。保守模式下允许不需要一致性维护需要的复制粘贴实例，可让程序开发人员更加安全的开发程序，从而避免可能的缺陷。激进模式下阻止需要一致性维护的复制粘贴实例，可尽可能的复用现有的程序，让程序开发人员更加快速的开发程序。在实际的使用中，程序人员可根据不同的需求选择使用相应模式。

\BiSection{实验设置}{}

\BiSubsection{实验系统}{}

为评估本文方法，本文选取了四个开源软件进行实验。实验系统的基本信息如表1所示，给出4个实验系统的复制粘贴实例的统计信息。从表~\ref{cpsta}~中可看出，软件系统中存在大量的复制粘贴实例，数量从633到3366。同时软件系统中的大多数复制粘贴实例不需要一致性维护(比例从59.8\%到88.47\%)。但是软件系统中也存在较多数量的需要一致性维护的复制粘贴实例(数量从73个到1353个)。

\begin{table}[htbp]
\bicaption[cpsta]{}{实验系统统计信息}{Table$\!$}{Information of ...}
\vspace{0.5em}\centering\wuhao
\begin{tabular}{cccc}
\toprule[1.5pt]
\multirow{3}{*}{\textbf{Project}}& \multicolumn{2}{c}{\textbf{Number (Percentage) of Change Instances}} & \multirow{3}{*}{\textbf{Total}}\\
  &\textbf{Consistency-} &\textbf{Meeting} &  \\
  &\textbf{Requirement Free}&\textbf{Consistency-Requirement}& \\
\midrule[1pt]
ArgoUML&	2574(77.07\%)&	766(22.93\%)&	3340\\
JEdit&	560(88.47\%)&	73(11.53\%)&	633\\
JFreeChart&	2013(59.80\%)&	1353(40.20\%)&	3366\\
Tuxguitar&	1016(71.10\%)&	413(28.90\%)&	1429\\
\bottomrule[1.5pt]
\end{tabular}
\end{table}

\BiSubsection{评估方法}{}

本文研究问题是复制粘贴实例的分类问题，采用机器学习方法解决该问题。机器学习领域中有较多的分类方法可以解决分类问题，如贝叶斯方法、决策树方法。本文分别使用贝叶斯网络分类器和其它的分类器进行实验。在贝叶斯网络实验中，预测方法为贝叶斯网络，并从三个不同的角度对本文方法进行全面评估。在分类器评估中，本文分别选取了几种不同的分类器，包括贝叶斯网络、朴素贝叶斯、决策树和决策树森林分类器，验证本文方法一般分类器上的预测能力。

由于复制粘贴操作有两种状态，即需要和不需要一致性维护，因此本文同样有两种使用模式与之对应（保守模式和激进模式）。在不同的模式下分别使用三种指标度量评估本文方法的预测能力。

在保守模式下，对不需要一致性维护需求的复制粘贴实例进行评估。仅允许不需要一致性维护操作，从而防止导致额外维护代价。使用三个度量评估该使用模式：推荐率、准确率和召回率。
\begin{itemize}
\item	推荐率(Recommendation Rate，RR)：指的是所推荐的不需要一致性维护的复制粘贴实例，即预测为不需要一致性维护的复制粘贴实例与系统中全部实例的比值。
\item  准确率(Precision，P)：指所推荐的不需要一致性维护复制粘贴实例的准确率，即在预测为不需要一致性维护的复制粘贴实例中，正确预测的实例与所预测实例的比值。
\item  召回率(Recall，R)：指所推荐的不需要一致性维护的复制粘贴实例的查全率，即预测为不需要一致性维护的复制粘贴实例，与系统中的不需要一致性维护的实例的比值。
\end{itemize}

在激进模式下，对需要一致性维护需求的复制粘贴实例进行评估。仅阻止那些需要一致性维护需求的复制粘贴实例，从而可以通过复用现有代码快速开发软件。同样使用三个度量进行评估：警告率、准确率和召回率：
\begin{itemize}
\item	警告率(Warning Rate，WR)：指所警告的需要一致性维护的复制粘贴实例，即预测为需要一致性维护的复制粘贴实例与系统中全部实例的比值。
\item	准确率(Precision，P)：指所警告的需要一致性维护的复制粘贴的准确率，即在所警告的需要一致性维护的复制粘贴中，正确预测的实例与所警告实例的比值。
\item	召回率(Recall，R)：指所警告的需要一致性维护的复制粘贴实例的查全率，即预测为需要一致性维护的复制粘贴实例，与系统中的需要一致性维护实例的比值。
\end{itemize}

\BiSection{实验结果及分析}{}

\BiSubsection{贝叶斯网络评估}{}

本节使用贝叶斯网络方法对复制粘贴实例进行一致性需求维护。贝叶斯网络是一种概率模型，使用已经发生的事件预测将来可能发生的事件\cite{friedman1997bayesian}。贝叶斯网络模型的生成和训练均使用开源软件工具WEKA。将复制粘贴实例划分为训练集和测试集，使用训练集训练贝叶斯网络生成预测模型，使用K2搜索算法建立网络结构，并设置贝叶斯网络最大父节点个数为3。使用测试集评估贝叶斯网络的预测能力，贝叶斯网络会计算每一个复制粘贴实例的概率值，表示该实例需要一致性维护需求的概率(在0~1之间，数值接近于1表示需要一致性维护，接近于0表示不需要一致性维护)。

贝叶斯网络实验可以分为全属性实验、属性组实验和交叉验证实验三个部分。全属性实验室采用所有的度量在所有系统上进行实验，用于评估本文方法的能力。属性组实验分析不同属性组对实验结果的影响。交叉验证实验使用训练好的模型去预测新系统，从而探索将本文模型在应用到新系统的预测能力。全属性实验和属性组实验在数据集上使用十倍交叉验证，交叉验证实验将不同的系统划分为训练集和测试集。本文有两种使用模式，在不同的模式下的目标不同，因此设置不同阈值进行实验分析。在保守模式下，面向不需要一致性维护的实例，其贝叶斯预测值较小（接近于0），选取阈值为0.01、0.05、0.10、0.15和0.20，当预测值小于等于给定阈值时认定该实例不需要一致性维护需求。在激进模式下，面向需要一致性维护的实例，其贝叶斯网络预测值较大（接近于1），选取阈值为0.5、1.6、0.7、0.8和0.9，当预测值大于等于该阈值认定该实例需要一致性维护。

\BiSubsubsection{全属性实验}{}
全属性实验使用全部属性在四个实验系统上在两种使用模式上进行评估，实验结果如表2所示（其中阈值Threshold简写为T）。如表~\ref{}~所示，表左侧是保守模式下不同阈值的实验结果，表右侧是激进模式下不同阈值的实验结果。由表中可以看出，本文方法在两种模式下均取得了较好效果。在保守模式下，四个系统在不同的阈值的准确度较高（介于86.6~97.22\%），同时召回率也达到较高值（介于76.97~96.39\%）。在激进模式下，除jEdit外其余系统在不同阈值下取得了可以接受的效果：准确率介于75.79~94.94\%之间，召回率介于57.87~80.86\%之间。jEdit在激进模式下预测效果不够理想，其准确度和召回率仅在50\%左右。分析其原因可能为jEdit中训练数据过少导致模型不完全，数据集仅有73复制粘贴实例。尽管如此，jEdit的预测结果的准确度依然高于其系统自身的一致性维护需求的比例（11.53\%）。因此，在jEdit系统上依然提高了预测的精度，是有效的。综上，本文方法在使用全属性在贝叶斯网络作为分类器时，可以达到一个较好的预测效果。同时本文建议需要对预测模型进行完全训练，以达到较好的预测效果。

\begin{table}[htbp]
\bicaption[]{}{}{Table$\!$}{}
\vspace{0.5em}\centering\wuhao
\begin{tabular}{ccccc}
\toprule[1.5pt]
\textbf{Project}&\textbf{Threshold}&\textbf{RR(\%)}&\textbf{Precision(\%)}&\textbf{Recall(\%)}\\
\midrule[1pt]
\multirow{5}{*}{ArgoUML}
&0.01&	74.61&	95.91&	92.85\\
&0.05&	76.83&	95.21&	94.91\\
&0.1&	77.63&	94.83&	95.53\\
&0.15&  78.26&	94.68&	96.15\\
&0.2&	78.47&	94.66&	96.39\\
\multirow{5}{*}{jEdit}
&0.01&	73.93&	97.22&	81.25\\
&0.05&	78.67&	95.98&	85.36	\\
&0.1&	80.73&	95.11&	86.79	\\
&0.15&	81.67&	94.97&	87.68	\\
&0.2&	82.15&	94.62&	87.86	\\
\multirow{5}{*}{jFreeChart}
&0.01&	54.69&	92.40&	84.50\\
&0.05&	57.22&	91.23&	87.28\\
&0.1&	59.24&	89.72&	88.87\\
&0.15&	60.22&	89.15&	89.77\\
&0.2&	61.14&	88.87&	90.86\\
\multirow{5}{*}{Tuxguitar}
&0.01&	61.51&	88.96&	76.97\\
&0.05&	66.83&	87.96&	82.68\\
&0.1&	69.28&	87.47&	85.24\\
&0.15&	70.82&	86.96&	86.61\\
&0.2&	72.08&	86.60&	87.80\\
\bottomrule[1.5pt]
\end{tabular}
\end{table}

\begin{table}[htbp]
\bicaption[]{}{}{Table$\!$}{}
\vspace{0.5em}\centering\wuhao
\begin{tabular}{ccccc}
\toprule[1.5pt]
\textbf{Project}&\textbf{Threshold}&\textbf{WR(\%)}&\textbf{Precision(\%)}&\textbf{Recall(\%)}\\
\midrule[1pt]
\multirow{5}{*}{ArgoUML}
&0.9&	18.95&	94.94&	78.46\\
&0.8&	19.64&	92.84&	79.50\\
&0.7&	20.03&	91.93&	80.29\\
&0.6&	20.24&	91.27&	80.55\\
&0.5&	20.54&	90.23&	80.81\\
\multirow{5}{*}{jEdit}
&0.9&	10.27&	52.31&	46.58\\
&0.8&	12.16&	48.05&	50.68\\
&0.7&	12.80&	46.91&	52.05\\
&0.6&	13.59&	46.51&	54.79\\
&0.5&	14.06&	47.19&	57.53\\
\multirow{5}{*}{jFreeChart}
&0.9&	34.25&	91.67&	78.12\\
&0.8&	35.03&	90.75&	79.08\\
&0.7&	35.56&	90.31&	79.90\\
&0.6&	36.19&	89.49&	80.56\\
&0.5&	36.57&	88.87&	80.86\\
\multirow{5}{*}{Tuxguitar}
&0.9&	20.08&	83.28&	57.87\\
&0.8&	21.48&	81.76&	60.77\\
&0.7&	22.74&	79.38&	62.47\\
&0.6&	23.30&	78.38&	63.20\\
&0.5&	24.28&	75.79&	63.68\\
\bottomrule[1.5pt]
\end{tabular}
\end{table}

\BiSubsubsection{属性组实验}{}

本文提取了两组度量表示复制粘贴实例，分别为复制粘贴实例的代码属性和上下文属性。为了确定每一组属性对预测效果的作用，本文对属性组进行了评估，即属性组实验。在本实验中每次仅使用一组度量去预测实例的一致性维护需求，并观察其对预测结果的影响。表3和表4分别是在保守和激进模式下的四个实验系统的预测结果。

\begin{table}[htbp]
\bicaption[343]{}{}{Table$\!$}{}
\vspace{0.5em}\centering\wuhao
\begin{tabular}{cccccccc}
\toprule[1.5pt]
\multirow{2}{*}{\textbf{Project}}&\multirow{2}{*}{\textbf{Threshold}}&\multicolumn{3}{c}{\textbf{ Code(\%)}}&\multicolumn{3}{c}{\textbf{ Context(\%)}}\\
&&\textbf{RR}&\textbf{Precision}&\textbf{Recall}&\textbf{RR}&\textbf{Precision}&\textbf{Recall}\\
\midrule[1pt]
\multirow{5}{*}{ArgoUML}
&0.01&	70.75&	95.64&	87.80&	47.31&	98.10&	60.22\\
&0.05&	73.53&	95.07&	90.71&	61.74&	96.99&	77.70\\
&0.1&	74.82&	94.60&	91.84&	69.22&	96.24&	86.44\\
&0.15&	75.93&	94.32&	92.93&	71.53&	95.90&	89.01\\
&0.2&	76.59&	94.02&	93.43&	73.59&	95.52&	91.22\\

\multirow{5}{*}{jEdit}
&0.01&	72.20&    96.94&	79.11&	32.95&	99.10&	54.60\\
&0.05&	76.30&	96.48&	83.21&	42.19&	97.25&	68.60\\
&0.1&	78.67&	95.78&	85.18&	47.74&	95.02&	75.86\\
&0.15&	80.09&	95.66&	86.61&	52.55&	93.95&	82.56\\
&0.2&	81.36&	94.76&	87.14&	54.10&	93.36&	84.45\\


\multirow{5}{*}{jFreeChart}
&0.01&	39.69&	90.94&	60.36&	32.95&	99.10&	54.60\\
&0.05&	43.94&	87.96&	64.63&	42.19&	97.25&	68.60\\
&0.1&	46.70&	86.32&	67.41&	47.74&	95.02&	75.86\\
&0.15&	48.07&	86.16&	69.25&	52.55&	93.95&	82.56\\
&0.2&	48.66&	85.71&	69.75&	54.10&	93.36&	84.45\\


\multirow{5}{*}{Tuxguitar}
&0.01&	56.75&	89.15&	71.16&	29.60&	93.14&	38.78\\
&0.05&	64.52&	86.98&	78.94&	43.88&	92.34&	56.99\\
&0.1&	67.88&	86.80&	82.87&	51.99&	92.46&	67.62\\
&0.15&	69.56&	86.62&	84.74&	56.54&	91.58&	72.83\\
&0.2&	71.24&	86.05&	86.22&	59.69&	91.56&	76.87\\

\bottomrule[1.5pt]
\end{tabular}
\end{table}

\begin{table}[htbp]
\bicaption[32565]{}{}{Table$\!$}{}
\vspace{0.5em}\centering\wuhao
\begin{tabular}{cccccccc}
\toprule[1.5pt]
\multirow{2}{*}{\textbf{Project}}&\multirow{2}{*}{\textbf{Threshold}}&\multicolumn{3}{c}{\textbf{ Code(\%)}}&\multicolumn{3}{c}{\textbf{ Context(\%)}}\\
&&\textbf{WR}&\textbf{Precision}&\textbf{Recall}&\textbf{WR}&\textbf{Precision}&\textbf{Recall}\\
\midrule[1pt]
\multirow{5}{*}{ArgoUML}
&0.9&	17.96&	92.67&	72.58&	15.78&	98.10&	67.49\\
&0.8&	18.89&	89.54&	73.76&	16.98&	95.77&	70.89\\
&0.7&	19.67&	87.52&	75.07&	17.51&	94.02&	71.80\\
&0.6&	20.21&	85.93&	75.72&	18.50&	91.59&	73.89\\
&0.5&	20.78&	84.44&	76.50&	19.64&	87.80&	75.20\\

\multirow{5}{*}{jEdit}
&0.9&	9.48&	55.00&	45.21&	31.91&	96.65&	76.72\\
&0.8&	11.37&	52.78&	52.05&	33.87&	94.47&	79.60\\
&0.7&	13.27&	48.81&	56.16&	34.94&	93.54&	81.30\\
&0.6&	14.22&	45.56&	56.16&	35.89&	92.30&	82.41\\
&0.5&	14.85&	44.68&	57.53&	37.20&	90.97&	84.18\\

\multirow{5}{*}{jFreeChart}
&0.9&	27.04&	88.90&	59.79&	31.91&	96.65&	76.72\\
&0.8&	28.19&	87.57&	61.42&	33.87&	94.47&	79.60\\
&0.7&	28.85&	86.61&	62.16&	34.94&	93.54&	81.30\\
&0.6&	29.92&	84.61&	62.97&	35.89&	92.30&	82.41\\
&0.5&	30.57&	83.58&	63.56&	37.20&	90.97&	84.18\\

\multirow{5}{*}{Tuxguitar}
&0.9&	17.91&	82.03&	50.85&	11.06&	93.04&	35.59\\
&0.8&	20.22&	78.55&	54.96&	15.40&	87.27&	46.49\\
&0.7&	21.48&	76.55&	56.90&	20.50&	83.62&	59.32\\
&0.6&	23.02&	74.16&	59.08&	23.30&	80.18&	64.65\\
&0.5&	24.14&	71.88&	60.05&	26.94&	74.81&	69.73\\

\bottomrule[1.5pt]
\end{tabular}
\end{table}

表3为保守模式下的属性组实验结果，其中左侧为代码属性，右侧为上下文属性。由表中可以看出，代码属性实验结果表明预测效果依然较好，但和全属性实验对比发现代码属性实验的召回率下降，准确率除jEdit中少数几个之外也全部下降，因此本文提取的代码属性对预测作用具有积极意义。在上下文属性实验中，预测结果除JEdit系统外准确率提高，但是系统的召回率却大大降低。因此，在保守模式下上下文属性对系统的准确率影响较大，而代码属性对系统的召回率影响较大，同时两者对于预测都起到了积极的作用。

表4为激进模式下的属性组实验结果，其中左侧为代码属性，右侧为上下文属性。由表中可以看出，代码属性的实验结果明显不如全属性组实验，但仍在可接受的范围之内，说明代码属性对预测有积极的影响。上下文属性实验中，当仅仅使用上下文属性时部分系统的实验效果要优于全属性组实验，而部分系统的结果不如全属性组实验。因此，上下文属性对不同的系统所起到的作用并非一样的。上下文属性和代码属性都具有积极地意义，而上下文属性的影响更大。

综上所述，本文所提取的代码属性和上下文属性对复制粘贴操作的一致性维护需求的预测起到了积极的作用。但在不同系统中的两种使用模式下，所产生的影响程度不一致。本文建议维护人员可以根据项目需求或者自身需求适当的选择属性从而达到不同的要求目标，但仍需要进一步的实验进行验证。

\BiSubsubsection{交叉验证实验}{}

在系统开发的初始阶段，系统内可能没有足够的复制粘贴实例，从而导致模型训练不完全，进一步使得预测结果不够理想。为解决此问题，本文在不同的系统上进行了交叉验证实验，即使用已有系统的复制粘贴实例训练一致性预测模型，并用于预测其它系统的一致性维护需求。在交叉验证实验中，使用中三个系统的复制粘贴实例作为训练集，然后使用另外一个系统作为测试集测试模型的有效性。在四个系统在两种模式下的交叉验证实验结果如表5所示，表的第一列为测试系统，表左侧为保守模式，右侧为激进模式。

\begin{table}[htbp]
\bicaption[]{}{}{Table$\!$}{}
\vspace{0.5em}\centering\wuhao
\begin{tabular}{ccccc}
\toprule[1.5pt]
\textbf{Project}&\textbf{Threshold}&\textbf{RR(\%)}&\textbf{Precision(\%)}&\textbf{Recall(\%)}\\
\midrule[1pt]
\multirow{5}{*}{ArgoUML}
&0.01&	59.16&	73.03&	56.06\\
&0.05&	67.57&	75.59&	66.28\\
&0.10&	71.95&	76.28&	71.21\\
&0.15&	74.10&	76.40&	73.47\\
&0.20&	75.81&	76.18&	74.94\\

\multirow{5}{*}{jEdit}
&0.01&	78.99&	91.20&	81.43\\
&0.05&	85.62&	90.41&	87.50\\
&0.10&	87.52&	90.25&	89.29\\
&0.15&	89.10&	89.72&	90.36\\
&0.20&	90.21&	89.67&	91.43\\

\multirow{5}{*}{jFreeChart}
&0.01&	74.48&	60.07&	74.81\\
&0.05&	82.92&	60.01&	83.21\\
&0.10&	86.51&	60.65&	87.73\\
&0.15&	88.38&	61.01&	90.16\\
&0.20&	88.92&	60.84&	90.46\\

\multirow{5}{*}{Tuxguitar}
&0.01&	59.55&	75.44&	63.19\\
&0.05&	70.40&	74.16&	73.43\\
&0.10&	74.74&	74.91&	78.74\\
&0.15&	78.38&	74.29&	81.89\\
&0.20&	80.76&	74.00&	84.06\\

\bottomrule[1.5pt]
\end{tabular}
\end{table}

\begin{table}[htbp]
\bicaption[]{}{}{Table$\!$}{}
\vspace{0.5em}\centering\wuhao
\begin{tabular}{ccccc}
\toprule[1.5pt]
\textbf{Project}&\textbf{Threshold}&\textbf{WR(\%)}&\textbf{Precision(\%)}&\textbf{Recall(\%)}\\
\midrule[1pt]
\multirow{5}{*}{ArgoUML}
&0.90&	8.38&	15.36&	5.61\\
&0.80&	10.30&	15.70&	7.05\\
&0.70&	12.75&	20.19&	11.23\\
&0.60&	14.52&	18.76&	11.88\\
&0.50&	16.38&	20.66&	14.75\\

\multirow{5}{*}{jEdit}
&0.90&	2.37&	33.33&	6.85\\
&0.80&	3.95&	24.00&	8.22\\
&0.70&	5.53&	20.00&	9.59\\
&0.60&	6.64&	19.05&	10.96\\
&0.50&	6.95&	20.45&	12.33\\

\multirow{5}{*}{jFreeChart}
&0.90&	2.70&	50.55&	3.40\\
&0.80&	4.72&	61.01&	7.17\\
&0.70&	6.36&	54.67&	8.65\\
&0.60&	6.95&	53.42&	9.24\\
&0.50&	7.46&	52.59&	9.76\\

\multirow{5}{*}{Tuxguitar}
&0.90&	6.02&	53.49&	11.14\\
&0.80&	7.98&	55.26&	15.25\\
&0.70&	8.89&	52.76&	16.22\\
&0.60&	10.15&	49.66&	17.43\\
&0.50&	11.69&	44.31&	17.92\\
\bottomrule[1.5pt]
\end{tabular}
\end{table}

在保守模式下，四个系统的准确率和召回率依然达到了较高的水平，其中准确率在60.01~91.20\%之间,召回率56.06~91.43\%之间。对比发现JEdit的预测效果最好(准确率较高)，而JFreeChart预测效果最差。分析原因可能是由于JEdit系统的训练集最大，模型训练最充分，而JFreeChart则与之相反。将实验结果与全属性实验对比发现，四个系统的预测效果都大幅下降。因此，预测模型的预测能力会依赖于自身系统数据的训练。鉴于此，本文建议优先选用系统自身的数据进行一致性为需求预测；在自身系统数据较少，不足以较好的训练模型的情况下，可以使用其它系统的数据对模型进行训练。

在激进模式下，四个系统的预测效果极具下降，准确率在15.36~61.01\%之间，召回率则更低，仅在10\%徘徊。与全属性实验对比发现，四个系统的预测效果下降的都十分极为严重(相比较于保守模式)。分析原因是复制粘贴实例中大部分的数据是不需要一致性维护需求，而需要一致性维护的实例数量太少，从而预测模型训练不够完善。另一个可能的原因是在激进模式下，本文的预测结果也更依赖于具体的系统，不太适合于使用系统交叉的方式进行预测。因此，在激进模式下，本文不建议使用交叉验证的方式进行预测。

综上所述，在进行一致性维护需求预测时，本文建议优先选用自身的数据进行模型训练，并对自身系统进行预测。当自身系统的数据太少而不足以训练模型时，应该尽量使用大量的数据训练模型从而使模型训练完备。同时，本文不建议在激进模式下使用系统交叉的方式进行一致性维护进行预测。

\BiSubsection{一般分类器评估}{}

为验证本文方法的一般适用性，除了使用贝叶斯网络进行预测之外，本文还在多个分类器进行了实验。分别选取四个分类器为：贝叶斯网络、朴素贝叶斯网络、决策树和随机森林。多分类器实验中分类器均采用WEKA实现并使用默认参数配置。

在两种模式下的多分类器实验结果如表6所示。表中统计了四个实验系统使用不同分类器的预测结果，分别统计了两种模式下的准确率和召回率，表中的“平均”是指两种模式下的平均预测结果。从表中可以看出，四种分类方法在四个系统上的平均实验结果都达到了较好的预测结果，准确率和召回率均在78.3~95.8\%之间。而JEdit系统在使用决策树进行预测时，无法正确预测和识别复制粘贴实例的一致性维护需求。分析其原因是JEdit系统的复制粘贴实例数据太少，模型训练不完全而导致实验结果不够理想。综上，本文的方法可适用于本文方法可以适用于一般的分类和预测方法，维护人员可以根据自己的需求选取相应的预测方法，同时仍需要进一步的实验，验证和调整该预测方法的参数，从而获取最佳的效果。


\begin{table}[htbp]
\bicaption[345467]{}{}{Table$\!$}{}
\vspace{0.5em}\centering\wuhao
\begin{tabular}{cccccccccc}
\toprule[1.5pt]
\multirow{2}{*}{\textbf{Project}}&\multirow{2}{*}{\textbf{模式}}&\multicolumn{2}{c}{\textbf{ 贝叶斯}}&\multicolumn{2}{c}{\textbf{ 朴素贝叶斯(\%)}}&\multicolumn{2}{c}{\textbf{ 决策树}}&\multicolumn{2}{c}{\textbf{ 随机森林}}\\
&&\textbf{Precision}&\textbf{Recall}&\textbf{Precision}&\textbf{Recall}&\textbf{Precision}&\textbf{Recall}&\textbf{Precision}&\textbf{Recall}\\
\midrule[1pt]
\multirow{3}{*}{ArgoUML}
&保守	&94.5&	97.4&	91.7&	94&	90.7&	98.5&	95.5&	99.1\\
&激进	&90.2&	80.8&	78&	71.4&	93&	66.1&	96.6&	84.5\\
&平均	&93.5&	93.6&	88.6&	88.8&	91.2&	91.1&	95.8&	95.7\\

\multirow{3}{*}{jEdit}
&保守&	94.3&	47.2&	94.1&	85&	88.5&	1&	91.9&	98.9\\
&激进&	91.6&57.5&	33.9	&58.9	&0	&0	&80&	32.9\\
&平均&	88.9&	87.7&	87.1&	82&	78.3&	88.5&	90.5&	91.3\\

\multirow{3}{*}{jFreeChart}
&保守&	87.9&	93.2&	86.3&	92.7&	85.7&	95.8&	89.2&	94.7\\
&激进&	88.9&	80.9&	87.8&	78	&92.4	&76.3	&91.3	&83\\
&平均&	88.3&	88.2&	86.9&	86.8&	88.4&	87.9&	90.1&	90\\

\multirow{3}{*}{Tuxguitar}
&保守&	86.1&	91.7&	85.3&	85.8&	89.2&	94.4&	88&	96.3\\
&激进&	75.8&	63.7&	64.6&	63.7&	83.9&	71.9&	88.1&	67.8\\
&平均&	83.1&	83.6&	79.3&	79.4&	87.7&	87.9&	88&	88\\

\bottomrule[1.5pt]
\end{tabular}
\end{table}

\BiSection{相关工作}{}
人们最开始认为克隆代码是一种最臭名昭著的代码。克隆代码的存在会对系统产生不利的影响，因此建议使用重构方法消除克隆代码\cite{fowler2009refactoring}。从而引发了软件工程领域中对克隆代码是否有害的讨论，克隆有害性问题也成为了克隆代码领域的研究热点。有研究者支持克隆代码是有害的观点，认为克隆代码会导致软件缺陷，并增加系统的维护代价。例如Lozano等人对克隆代码的可变性进行研究，发现克隆代码会增加其所在方法的维护代价从而导致系统维护代价的增加\cite{lozano2008assessing}。同时，Juergens等人对通过对不一致变化进行研究，发现克隆不一致变化在软件中会频繁发生，也更容易导致克隆缺陷产生\cite{juergens2009code}。与之相反也有研究者认为克隆代码是无害的。例如Kapser等人对几种克隆模式优缺点进行了对比分析，发现71\%的克隆代码对系统的可维护性具有积极的影响\cite{}[kapser2006cloning]。Krinke等人对克隆和非克隆代码的对比发现，克隆代码比非克隆代码的寿命更长，同时也更加稳定不易发生变化\cite{krinke2011cloned}。Ishihara等人对克隆代码进行了可复用性分析，并建立了一个克隆代码复用的模型帮助程序人员复用克隆代码\cite{ishihara2013reusing}。

软件缺陷预测一直以来都是软件工程领域的研究热点问题，可以帮助开发人员发现软件中的尚未被发现的缺陷。软件缺陷预测方法一般从软件产品中提取相应的度量，然后使用机器学习方法预测软件是否存在缺陷。例如Hassan等人基于代码变化过程提取相关度量值用于缺陷预测中，经研究发现这些度量值在缺陷预测中具有较好的预测效果\cite{hassan2009predicting}。Wang等人通过提取三组不同的度量值在复制粘贴之时使用贝叶斯网络预测克隆代码的有害性\cite{wang2012can}。同时还将该方法进行了扩展，用于预测克隆代码的一致性维护需求\cite{wang2014predicting}。实验表明该方法可有效地预测克隆代码的一致性维护需求。但该方法存在一定的不足之处：首先克隆代码的一致性定义无法精确的处理类型3的克隆代码；然后在预测时必须使用被复制代码的历史信息，不利于将该方法应用于软件开发过程中；最后，其仅对贝叶斯网络进行了实验验证，并没有考虑其它的分类方法。鉴于此，本文改进了并扩展了克隆代码的一致性维护需求的预测工作：首先给出了更为精确的克隆一致性变化和维护需求定义，可以更精确的定义克隆代码的一致性维护需求；然后本文仅使用两组度量组表示复制和贴操作；最后在四种不同的分类方法上进行一致性维护需求预测。

研究人员一直致力于对克隆代码检测的研究，提出和开发了许多克隆代码检测方法和工具,如NiCad\cite{roy2008nicad}、CCFinder\cite{kamiya2002ccfinder}、iClone\cite{gode2009incremental}等。根据所使用的技术可将克隆检测工具划分为Text-based、 Token-based、Tree-based、Praph-based和Metric-based的方法。其中，NiCad是一个Text-based的克隆检测工具，可以较好地检测Type 1、2和3的克隆代码\cite{roy2009comparison}。CCFinder是一种Token-based的检测工具，可以有效的检测Type1和2的克隆代码，还可以对克隆代码进行度量分析从而帮助维护人员理解克隆代码\cite{kamiya2002ccfinder}。iClone是一个Tree-based的增量式克隆检测工具，可支持增量式的检测系统中的Type 1、2和3的克隆代码，同时还可以对克隆代码进行演化分析\cite{gode2009incremental}。由于有较多的克隆代码检测方法和工具，为了方便进行分析和评估不同方法的优缺点，研究人员还对其进行了综述和工具评估。例如Rattan\cite{rattan2013software}使用标准的文献综述方法，在详细分析了213篇相关文章的基础上，对克隆代码检测方法和工具进行了细致的综述和评估。该文献极具参考意义，有兴趣的读者可以进一步阅读。克隆代码不仅存在于软件系统中，同时也会伴随着系统演化。为了分析克隆代码的演化情况，Kim提出了的克隆家系的概念\cite{}。克隆家系是克隆组的一个有向无环图，可以完整的描述克隆代码的演化过程和在其演化过程中的变化情况。克隆家系研究开启了人们对于多版本软件的克隆代码演化研究。Kim所提出的克隆家系可以完整的描述Type 1和2的克隆代码的演化情况，却无法描述Type 3的演化过程。因此在Kim的基础上，Saha提出了一个更为精细的定义描述克隆代码的变化，尤其是Type 3克隆代码的一致性变化和不一致性变化\cite{}。考虑到克隆代码的一致性变化所引起的克隆一致性维护代价时，Saha的定义又显得过于精确，并不能完全描述一致性维护代价。因此，本文在上述基础上，给出了一个折中的定义可以适应克隆代码一致性维护需求的预期，具体见上文。

克隆代码的检测与演化研究可以帮助我们理解克隆代码，但是并不能实际解决克隆代码所带来的影响。因此近几年研究人员开始对克隆代码维护和管理的研究，希望可以彻底解决克隆代码问题。最初的研究中人们致力于使用重构方法消除系统中的克隆代码。如Higo等人提出的基于度量值的重构方法,可以识别出可重构克隆代码并将其重构\cite{higo2008metric}。随着研究的深入，研究人员开始提出克隆管理方法。Nguyen实现了一种可用于管理和维护克隆代码的eclipse插件\cite{JSync[nguyen2012clone}。该插件支持在软件开发过程中对克隆代码进行克隆关系管理和一致性维护管理。而另一个较早提出的eclipse插件CeDAR将克隆检测和克隆重构融为一体，对现有克隆检测工具的克隆检测结果进行克隆重构\cite{tairas2012increasing}。

\BiSection{结论}{}
由于复制粘贴操作会在系统中引入克隆代码，而所引入的克隆代码由于一致性变化而导致额外的维护代价。本文为了帮助程序开发人员避免克由复制粘贴操作而引发的额外维护代价，提出了一种基于机器学习的克隆代码一致性维护需求预测方法。通过构建软件系统的克隆家系收集系统中的复制粘贴操作实例，并从不同的角度提取代码属性和上下文属性表示复制粘贴实例。在对复制粘贴实例进行演化分析并进行一致性需求维护的基础上获取实验所需的数据集。经过在四个开源系统上进行实验评估后，实验结果表明本文方法可以以较高的准确率和召回率预测克隆代码的一致性维护需求。具体地，在全属性实验和一般分类器评估中，实验结果表明本文方法具有较高的预测效果；属性组实验结果表明所提取的两组属性组在预测中均起到了积极的作用，但是对准确率和召回率有不同的影响，并且也依赖于具体的系统；交叉验证实验结果虽然不如全属性实验，但仍在可接受范围内。因此，本文建议对系统进行一致性需求预测时，优先选用自身数据进行训练，并可以根据不同的系统选择不同的度量值以满足程序开发人员的需求。

本文方法还可以方便的集成到软件开发环境中（如eclipse），从而在开发时帮助程序开发人员进行一致性维护需求预测。在未来工作中，将会考虑实现一个预测插件，将本文方法切实的应用到软件开发过程中帮助提高软件质量。在交叉验证实验中，使用本文方法预测新系统时，预测效果仍有很大的提升空间。在未来的研究中，将考虑提取并使用新的属性以适用于交叉验证的预测。将考虑训练一个克隆代码一致性维护需求的一般性模型，使其对所有的系统都具有较高的准确率和召回率，进而将其应用于全新系统的一致性维护需求预测中。
