% !Mode:: "TeX:UTF-8" 

\BiChapter{绪论}
{Introduction}

\BiSection{课题背景及研究目的和意义}{Background, research objective and significance}

本课题来源于国家自然科学基金面上项目“无定型克隆代码的检测与重构方法”（批准号：61173021）。

随着计算机软件广泛应用于经济、军事、商业等各个领域中，软件质量问题日益得到人们的广泛重视。保证软件高质量，并提高软件可维护性、可理解性已经成为系统开发和维护工作的一个不可或缺的重要方面。然而，随着应用需求和应用环境的不断变化，现实世界的软件系统也随着时间在不断演化，软件规模越来越大、逻辑越来越复杂，因此软件的质量、可维护性和可理解性也在逐渐的下降。

与此同时，软件复用作为一种常见的软件开发手段可以提高软件开发效率，但是也会往软件中引入大量的克隆代码。研究表明，软件工程实践中会产生多种类型的克隆代码，克隆代码在大型软件系统中约占代码总量的7-23\%\cite{roy2007survey}。随着时间的推移和软件系统功能的不断添加，软件系统的规模越来越大、结构越来越复杂，系统中的克隆代码也越来越多。
有研究人员认为克隆代码是一种代码坏味\cite{fowler2009refactoring}，克隆代码的存在会对软件系统造成不可避免的影响。
%具体化？
%因此，克隆代码的存在会影响软件的质量，增加软件维护的成本和难度。
因此，克隆代码是影响软件质量、可维护性和可理解性的一个重要因素，如何理解和分析系统中既有的克隆代码，并对其进行有效的维护是一个值得研究的问题。目前对克隆代码的分析和维护研究已成为软件工程领域中的一个研究热点，同时也是亟待解决的一个问题。

研究人员开展了大量且较为深入的克隆代码研究，并取得了较多的研究成果。对克隆代码的研究可以划分为三个主要的研究方面，即克隆代码检测、克隆代码分析和克隆代码维护。
在当前对克隆的研究活动中，克隆代码检测是最主要的研究活动，也是进行较为完备的研究内容。到目前为止，已经研究和开发出许多克隆代码检测的方法和工具，可以一定程度上识别系统中存在的多种类型的克隆代码。但由于克隆代码大量存在并且情况复杂，克隆检测结果并不是完全令人满意的。当前方法对于近似克隆代码检测效果并不好，同时无法完整的检测系统四型克隆。
更令人值得注意的是，对克隆代码检测的研究无法消除克隆代码对软件的不利影响，更无法直接帮助提高软件的质量以及可维护性。而克隆代码分析和维护研究可以更好地弥补这一不足。

本文通过对克隆代码的分析和维护研究，帮助维护人员理解和维护软件系统中的克隆代码，可以提高软件质量、软件可理解性和可维护性。
克隆分析是当前对克隆代码研究的一项重要活动，是对既有克隆代码的分析活动，可以帮助程序人员理解克隆代码。经研究发现克隆代码是会随着软件演化而演化，在其演化过程中克隆代码会对软件系统产生影响，同时也表现出了不同的特征。如何深入的分析克隆代码及其演化情况，从而揭示克隆代码所隐含的信息是一个值得研究的问题。通过对克隆代码的演化分析并获取克隆代码的演化特征，对于维护人员理解克隆代码及其演化过程具有积极的意义，可以帮助提高软件的可理解性。
于此同时，克隆维护研究也是克隆研究的另一项重要活动，旨在帮助维护系统中的克隆代码。在克隆代码的演化过程中，往往会有相当数量代码频繁的发生变化，称之为一致性变化或者不一致变化。这些变化的克隆代码可能需要一致性的维护，而遗忘这种维护也会导致缺陷的引入，进一步导致维护代价增大。因此，如何识别和预测需要一致性维护的克隆代码也是值得研究的问题。通过识别和避免克隆代码的一致性维护需求，可以有效的避免一致性缺陷，也可以大大降低克隆代码所导致的代价，可以帮助提高软件质量和可维护性。

基于以上分析，针对大型软件系统对软件可靠性要求较高的实际应用背景和需求，本文研究基于机器学习的克隆代码分析和维护方法 ，帮助维护人员理解和维护软件系统中的克隆代码。首先，本文结合聚类分析和克隆演化的研究成果，重点研究克隆代码演化特征分析，从克隆片段、克隆组和克隆家系三个不同角度提取相应的度量值并聚类克隆代码，揭示软件系统的克隆代码隐含的信息。然后，针对克隆代码一致性变化所导致的缺陷以及额外的维护代价问题，基于贝叶斯网络分别在复制粘贴之时和代码变化之时预测克隆代码的一致性维护需求。最后，并将上述预测扩展到其它的机器学习方法上，并帮助程序人员选择克隆一致性维护需求的模型。本文对于提高软件质量，使软件更易于理解和维护，不仅具有重要的科学理论意义，还具有重要的实际应用价值。


\BiSection{国内外研究现状及其分析}{Related work}

克隆代码（简称克隆）是根据某种相似性的定义彼此相似的代码片段\cite{koschke2007survey}。导致克隆代码产生的原因是多种多样的，最常见的形式是通过复制粘贴操作复用已有的代码。研究结果表明系统中通常存在着大量的克隆代码，比其例大约在为7-23\%左右，有的甚至高达59\%\cite{roy2007survey}。长期存在于系统中的克隆代码，不仅影响着系统的可维护性，也影响着系统的可理解性。因此，对克隆代码的维护需求引发了一系列关于克隆代码的研究，包括克隆检测、克隆分析、克隆维护与管理等。

目前，使用最为广泛的一种克隆代码分类方法是按照克隆代码的语法和语义对克隆代码的相似程度进行定义和分类，将克隆代码划分为如下四种类型：
\begin{itemize}
\item {Type 1：除空格、格式和注释外，是完全相同的代码片段（简称1型克隆）。}
\item {Type 2：除标识符、常量、类型外，是语法结构相同的代码片段（简称2型克隆）。}
\item {Type 3：拷贝粘贴后修改的代码片段，如改变、增加或删除少量语句的代码，是语法结构相似的代码片段（简称3型克隆）。}
\item {Type 4：执行相同的功能，但使用不同的语法结构实现的代码片段，是语义相似的代码（简称4型克隆）。}
\end{itemize}

其中，Type 1克隆也称为精确克隆，Type 2和Type 3克隆也称为近似克隆，前三类克隆代码是属于语法相似的克隆代码。Type 4克隆是语义相似的克隆代码。


\BiSubsection{研究热点与趋势}{Research hot spot and trend}
克隆代码一直以来都是软件工程领域的一个热点问题，迄今为止已有超过20年的研究时间。在此期间，研究人员发表了大量的学术论文，也取得了较多的研究成果。为方便研究人员查阅相关研究，截止到2013年阿拉巴马大学一直维护着一个克隆代码领域的文献库\footnote{ http://students.cis.uab.edu/tairasr/clones/literature/ 阿拉巴马大学关于克隆代码研究的文献库。该文献库更新至2013年，现已停止维护。} 。该文献库收录包括学术论文、技术报告以及学位论文在内的353篇文献，并按照研究内容和目标将克隆代码研究划分为以下4个研究方向：
\begin{itemize}
\item {克隆检测方向：该方向目录下列出了与克隆代码检测相关的研究内容，旨在使用不同的方法从系统中检测出克隆代码。}
\item 克隆分析方向：该方向目录下列出了与克隆代码分析相关的研究内容，旨在帮助程序开发人员分析系统中存在的克隆代码，从而理解克隆代码。
\item 克隆维护与管理方向：该方向目录下列出了与克隆代码维护与管理相关的研究内容，旨在通过各种技术手段维护和管理系统中的克隆代码。
\item 综述和工具评估方向：该方向目录下列出了克隆代码综述和克隆检测工具评估相关的研究内容。
\end{itemize}

根据此文献库中所给出的论文，Roy按照其分类方法进行了统计分析，分析了每个研究方向的论文分布情况和研究进展\cite{roy2014vision}。但是该文献库仅收录了2013年以前的文献，为了分析和反映克隆代码研究的最新进展、研究热点和发展趋势，本文在该文献库的基础上做了进一步的扩展，检索和收集了近三年的克隆代码相关文献，并按文献库分类方式进行了重新统计和分析。本文统计和收集的文献共分为三类，即软件工程领域的重要国际会议论文、重要国际期刊论文以及相关学位论文。其中，重要国际会议论文为432篇，期刊论文113篇，学位论文30篇，共计575篇\footnote{本文统计的所有文献可分为两个部分：一是来源于阿拉巴马大学的文献库，二是笔者在进行研究期间所阅读整理和收集的文献。在收集的过程中，已经对文献进行了初步筛选，仅选取了领域内权威期刊、会议以及学位论文。} 。

\begin{figure}[htbp]
\centering
\includegraphics[width = 0.8\textwidth]{literaturedistribution1}
\bicaption[literaturedistribution1]{}{克隆代码研究领域文献分布}{Fig.$\!$}{Literature distribution of code clone research}\vspace{-1em}
\end{figure}

克隆代码研究领域的文献统计分析结果如图~\ref{literaturedistribution1}~所示。从图中可以看出，对克隆检测与分析的研究较为充分，克隆检测和分析是克隆研究的研究热点，分别占比37.39\%和38.09\%，而克隆维护与管理的研究论文占比较少（占16.87\%），说明目前对该方向的研究还方兴未艾。克隆综述和工具评估方面的研究占比更少，仅为7.65\%，说明目前较为实用的工具还不够充分。

\begin{figure}[htbp]
\centering
\includegraphics[width = 0.8\textwidth]{literaturedistribution21}
\bicaption[literaturedistribution21]{}{克隆领域每年发表的论文数量}{Fig.$\!$}{Annual number of papers published in code clone research}\vspace{-1em}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width = 0.8\textwidth]{literaturedistribution22}
\bicaption[literaturedistribution22]{}{各个克隆研究活动每年发表的文献数量}{Fig.$\!$}{Annual number of papers published of each clone research activity}\vspace{-1em}
\end{figure}


为便于分析克隆代码研究领域的发展趋势，本文又对克隆代码研究领域的文献按照发表年份和研究方向进行了统计。统计分析结果如图~\ref{literaturedistribution21}~和~\ref{literaturedistribution22}~所示，其中图~\ref{literaturedistribution21}~是领域整体上每年发表文献数量的统计情况，图~\ref{literaturedistribution22}~是在不同研究方向上每年发表文献数量的统计情况。

从图~\ref{literaturedistribution21}~可以看出，克隆研究可以划分为两个阶段：1990-2003年和2004-2016年。在2003年以前，克隆代码研究领域的文献数量较少，这一阶段是克隆代码研究的孕育期。而在2004年以后的近10年内，克隆代码研究领域的文献数量快速增长，并且保持在一个较高的水平上，展现出了蓬勃的发展趋势，表明此阶段是克隆代码研究的发展期。与图~\ref{literaturedistribution21}~类似，从图~\ref{literaturedistribution22}~在不同研究方向上每年发表的文献数量来看，其研究趋势也以2003年为界限划分为两个阶段。在2003年以前，克隆代码研究主要集中在克隆检测方向，处于孕育期。在2004年以后，各个研究方向的文献数量都有了快速增长，进入了发展期。其中尤以克隆检测和分析方向的发展最为迅速，发表了大量研究成果，并依然有继续增长的趋势，说明克隆检测和分析事目前研究最为充分和最为活跃的研究方向。相比之下，克隆维护和管理仅在近几年才引起人们的关注，对克隆维护和管理的研究虽然近几年才刚开始起步，文献数量占比相对较少，但已呈现出逐年增长和后来者居上的趋势，说明克隆维护和管理正在逐渐成为克隆代码研究领域的新热点。

%\begin{figure}[htbp]
%\centering
%\subfigure{\label{literaturedistribution21}}\addtocounter{subfigure}{-2}
%\subfigure[Clone number of papers published each year in the field]{\subfigure[克隆领域每年发表的论文数量]{\includegraphics[width=0.8\textwidth]{literaturedistribution21}}}
%\subfigure{\label{literaturedistribution22}}\addtocounter{subfigure}{-2}
%\subfigure[Each clone number of events annually published literature]{\subfigure[各个克隆活动每年发表的文献数量]{\includegraphics[width=0.8\textwidth]{literaturedistribution22}}}
%\bicaption[literaturedistribution2]{}{克隆代码领域研究趋势}{Fig.$\!$}{Cloning research trends in the code field}\vspace{-1em}
%\end{figure}

%为便于分析克隆代码研究领域的发展趋势，本文又对克隆代码研究领域的文献按照发表年份和研究方向进行了统计。统计分析结果如图~\ref{literaturedistribution2}~所示，其中图~\ref{literaturedistribution21}~是领域整体上每年发表文献数量的统计情况，图~\ref{literaturedistribution22}~是在不同研究方向上每年发表文献数量的统计情况。
%从图~\ref{literaturedistribution21}~可以看出，克隆研究可以划分为两个阶段：1990-2003年和2004-2016年。在2003年以前，克隆代码研究领域的文献数量较少，这一阶段是克隆代码研究的孕育期。而在2004年以后的近10年内，克隆代码研究领域的文献数量快速增长，并且保持在一个较高的水平上，展现出了蓬勃的发展趋势，表明此阶段是克隆代码研究的发展期。与图~\ref{literaturedistribution21}~类似，从图~\ref{literaturedistribution22}~在不同研究方向上每年发表的文献数量来看，其研究趋势也以2003年为界限划分为两个阶段。在2003年以前，克隆代码研究主要集中在克隆检测方向，处于孕育期。在2004年以后，各个研究方向的文献数量都有了快速增长，进入了发展期。其中尤以克隆检测和分析方向的发展最为迅速，发表了大量研究成果，并依然有继续增长的趋势，说明克隆检测和分析事目前研究最为充分和最为活跃的研究方向。相比之下，克隆维护和管理仅在近几年才引起人们的关注，对克隆维护和管理的研究虽然近几年才刚开始起步，文献数量占比相对较少，但已呈现出逐年增长和后来者居上的趋势，说明克隆维护和管理正在逐渐成为克隆代码研究领域的新热点。

\BiSubsection{克隆检测研究}{Clone detection research}
克隆检测是指从软件中检测并报告克隆代码的位置的研究。相对于克隆代码研究的其他技术而言，克隆检测技术相对成熟。

\BiSubsubsection{克隆检测方法}{The methods of code detection}

一般而言，克隆代码检测分为三个步骤：代码的中间表示、相似性匹配和报告检测结果。首先使用不同的方法对源代码进行抽象表示或转换，将其表示为抽象语法树等中间表示形式。然后对代码的中间表示形式进行相似性匹配，寻找相似的代码片段。最后报告检测结果，将彼此相似的克隆代码以克隆组的形式保存在检测结果中。迄今为止，研究人员已提出许多种克隆检测方法，并开发了相应的检测工具。根据所使用的技术不同，可以将克隆检测划分为基于文本(Text)的方法、基于Token的方法、基于树(如Abstract Syntax Tree，AST)的方法、基于程序依赖图（Program Dependency Graph, PDG）的方法和基于度量值（Metric）的方法。

基于Text的克隆检测方法是通过直接比较源代码文本，使用字符串匹配等算法来检测克隆代码。因其并没有对源程序进行词法分析，大部分仅可以较好地支持Type 1克隆的检测，对其余类型克隆的支持较弱。目前使用较多的基于文本的克隆检测工具主要有duploc\cite{ducasse1999language}、Simian\cite{Simian}、DuDe\cite{wettel2005archeology}、SDD\cite{lee2005sdd}、NiCad\cite{roy2008nicad}等。

基于Token的克隆检测方法是通过对源代码进行词法分析，获得源代码的Token序列，然后通过寻找Token序列中相似的子序列来检测克隆代码。因其对源代码进行了词法分析，所以可以较好地检测Type 2克隆代码的检测。但由于缺乏必要的语法和语义分析，使其无法较好地支持Type 3和Type 4克隆的检测。目前使用较多的基于Token的克隆检测工具主要有Dup\cite{baker1995finding}、CCFinder\cite{kamiya2002ccfinder}、CP-Miner\cite{li2006cp}、iClone\cite{gode2009incremental}等。

基于Tree的克隆检测方法是将源代码表示为某种树的形式（如抽象语法树、代码解析树等），然后通过使用子树匹配算法从中寻找相似的子树来检测克隆代码。因其对源代码进行了语法分析，所以提高了克隆代码检测的准确率，尤其是可以较好地支持Type 3克隆的检测。但是由于子树匹配算法的时间复杂度高于前两种方法，因此这类算法的检测速度低于前两种方法。目前使用较多的基于Tree的克隆检测工具有CloneDr\cite{baxter1998clone}、SimScan\cite{SimScan}、Deckard\cite{jiang2007deckard}、CloneDigger\cite{bulychev2008duplicate}等。

前三种克隆检测方法中所使用的中间表示形式较为容易实现，可使用程序静态分析方法或者编译器前端获得源代码的中间表示。大部分的克隆检测方法和检测工具属于前三种方法中的一种，可以检测系统中的大部分克隆代码。

基于PDG的克隆检测方法的主要思路是，将源代码转化成程序依赖图(包括数据依赖图和控制依赖图)，然后通过寻找同构的子图来检测克隆代码。因程序依赖图表示了程序的语义信息，所以该方法可以支持语义相似的Type 4克隆代码的检测。但由于程序依赖图生成算法和图匹配算法的时间和空间复杂度极高，因而导致这类检测算法的时空开销过大，使其无法应用于大规模程序的克隆代码检测。目前基于PDG的克隆检测工具主要有Duplix\cite{krinke2001identifying}等。

基于Metric的克隆检测方法是先将源代码转换为某种中间表示，然后在其基础上提取度量值并抽象为一个特征向量，然后通过计算特征向量的相似度来检测克隆代码。该方法的主要优点是检测速度快。但因基于度量值的方法高度依赖于度量值的提取，在对源码提取度量值的过程中会损失源码的部分语义信息，因此检测效果不够理想，使其应用受限。

此外，还有人使用结合两种或两种以上检测技术的混合方法来检测克隆代码。例如，Deckard在生成抽象语法树的基础上提取结构特征向量表示代码，然后使用聚类的方法寻找克隆代码\cite{jiang2007deckard}。CloneMiner先将源代码表示为Token形式，然后在此基础上通过使用频繁模式挖掘算法寻找相似模式来检测克隆代码\cite{basit2009data}。


\BiSubsubsection{克隆检测方法及工具评估}{The evaluation of code clone detection methods and tools}

不同的克隆检测方法和检测工具各有其优缺点，分别适合检测不同类型的克隆代码，对同一类型的克隆代码的检测效果也不尽相同。如何针对具体的应用，选择合适的克隆检测方法和工具是困扰开发人员的一个问题。因此，研究人员对主流的克隆检测方法及其检测工具进行了评估研究，以期为用户选择方法和工具提供指导性的建议。Bellon对6个克隆检测工具进行了评估，分别对比了查准率、查全率以及时间和空间等性能\cite{bellon2007comparison}。Rattan通过使用一种标准的系统文献综述方法，详细分析了克隆检测方面的213篇文献，并对不同的检测方法进行了评估分析，并给出了未来的研究方向\cite{rattan2013software}。此外，Roy重点分析了检测工具的使用技术和适用环境，对克隆检测工具的检测效果进行了详细的对比，对帮助用户选择和使用克隆检测工具有重要的指导意义\cite{roy2009comparison}\cite{svajlenko2014evaluating}。

本文也对目前较为主流的克隆检测工具和方法支持的克隆类型和检测效果等进行了评估，评估结果如表1所示。其中，检测效果采用“较好”、“一般”和“较差”三种级别来评估：“较好”是指可以较好地支持该类型克隆代码；“一般”是指可以支持检测该类型克隆代码，但效果不佳；“较差”是指可以检测少部分的该类型克隆代码；对未支持的克隆类型未列出。

从表1可以看出，基于Text的检测工具不支持Type 4克隆的检测。对Type 1克隆的检测效果最好，对Type 3克隆的检测效果一般。而对Type 2克隆支持较弱，仅有两个工具可以支持。原因是Type 2克隆是标识符重命名的克隆代码，基于Text的方法不能很好地处理标识符重命名问题。基于Token的检测工具同样不支持Type 4克隆的检测，但是可以较好地检测Type 1和Type 2克隆。支持Type 2克隆检测的原因是在将源程序转换成Token序列时进行了词法分析，因此可以解决标识符重命名的问题。但仅有一个工具可以检测Type 3克隆代码，并且检测效果一般。基于Tree的检测工具，同样不支持Type 4克隆的检测，但是对Type 1克隆的检测效果较好，并且几乎都支持Type 2和Type 3克隆的检测。由于采用的匹配算法不同，对Type 3即近似克隆的检测效果不尽相同，有些可以较好地支持Type 2克隆的检测，有些则较好地支持Type 3克隆的检测。基于PDG的检测方法不仅可以较好地检测Type 1和Type 2克隆，还可以以不同的程度支持Type 3和Type 4克隆的检测。但因其复杂度相对较高，使其并没有太多的检测工具可以利用。基于Metric的检测方法目前仅有一些检测方法被提出\cite{kontogiannis1996pattern}\cite{mayrand1996experiment}，缺少相应的检测工具。

可见，目前克隆检测方法对Type 1和Type 2克隆的检测最简单，因此效果最好，检测工具也最多；对Type 3克隆的检测相对于前两种有一定的难度，因此效果一般，但也有少量工具支持；对Type 4克隆的检测难度最大，因此效果最差，工具最少。此外，基于Text、基于Token、基于Tree的克隆检测方法实现容易，是目前较为主流的方法，相应的检测工具也较多。基于PDG的克隆检测方法受到图匹配算法复杂性的影响使得这类方法的实现难度较大，因此实用工具不多。而基于Metric的克隆检测因为检测效果不够理想，所以研究较少，也没有可用的检测工具。其次，目前绝大多数的克隆检测工具仅支持单版本的克隆代码检测，无法同时检测多个版本中的克隆代码。少数的克隆检测工具（如iClone）采用了增量式的克隆代码检测方法，即在旧版本克隆检测的基础上对新版本进行克隆代码检测，从而节约了检测时间，提高了检测效率。此外，目前绝大部分的克隆检测工具也没有集成到软件开发环境中，开发人员无法在开发过程中实时地检测和跟踪克隆代码。因此，研究如何提高Type3和Type 4克隆的检测效果，以及如何在软件开发过程中增量式地检测克隆代码，这既是一个难点问题，也是未来的一个研究重点问题。


\begin{table}[htbp]
\bicaption[clonedetection]{}{主流克隆检测方法与工具评估}{Table$\!$}{Evaluation for popular clone detection methods and tools}
\vspace{0.5em}\centering\wuhao
\begin{tabular}{cccc}
\toprule[1.5pt]
类型&工具或方法名&支持的克隆类型&检测效果\\
\midrule[1pt]
\multirow{5}{*}{Text} 
& Duploc\cite{ducasse1999language}&1、3&较好1，一般3\\
&Simian\cite{Simian}&1、2	&较好1，一般2\\
&DuDe\cite{wettel2005archeology}&1、3	&较好1，一般3\\
&SDD\cite{lee2005sdd}&1、3	&较好1，一般3\\
&NiCad\cite{roy2008nicad}&	1、2、3	&较好1、2、3\\
\midrule[1pt]
\multirow{4}{*}{Token} 
&Dup\cite{baker1995finding}&	1、2&较好1、2\\
&CCFinder\cite{kamiya2002ccfinder}&1、2&较好1、2\\
&CP-Miner\cite{li2006cp}&1、2、3&较好1、2，一般3\\
&iClone\cite{gode2009incremental}&1、2	&较好1，2\\
\midrule[1pt]
\multirow{4}{*}{Tree} 
&CloneDr\cite{baxter1998clone}&	1、2、3	&较好1、3，一般2\\
&SimScan\cite{SimScan}&	1、2	&较好1、2\\
&Deckard\cite{jiang2007deckard}&	1、2、3	&较好1、2，一般3\\
&CloneDigger\cite{bulychev2008duplicate}&	1、2、3	&较好1、3，一般2\\
\midrule[1pt]
\multirow{2}{*}{PDG} 
&Duplix\cite{krinke2001identifying}&	1、2、3、4	&较好1、2，一般3，较差4\\
&Gabel\cite{gabel2008scalable}&1、2、3、4	&较好1、2、3，一般4\\
\midrule[1pt]
\multirow{2}{*}{Metric} 
&Kontogiannis\cite{kontogiannis1996pattern}&	1、2、3、4	&较好1、2，较差3、4\\
&Mayrand\cite{mayrand1996experiment}&	1、2、3、4	&较好1、2，较差3、4\\
\bottomrule[1.5pt]
\end{tabular}
\end{table}

\BiSubsection{克隆代码分析}{Code Clone Analysis}
克隆分析是指使用各种技术手段分析系统中的克隆代码，并挖掘其隐含的特征，旨在帮助软件开发人员更好地理解和维护克隆代码。目前的克隆分析研究主要集中在克隆演化分析、克隆评价分析和克隆可视化分析等方面。

\BiSubsubsection{克隆代码演化}{Code Clone Evolution}

克隆代码往往存在于软件系统的多个版本中，并随着软件系统进行演化。克隆代码演化分析就是通过分析克隆代码的演化过程，提取克隆代码的演化特征，识别克隆代码的演化规律，从而辅助人们更好地理解和维护克隆代码。克隆演化研究包括克隆演化过程分析和演化特征分析两个方面。演化过程分析即模型化克隆代码的演化过程。演化特征分析是分析克隆代码在演化过程中表现出来的演化特征或演化模式及其对软件质量的影响。

克隆演化过程分析最早是2001年由Antoniol等人提出的，他们使用时间序列描述克隆代码的演化模型\cite{antoniol2001modeling}，但并未引起人们的重视。2005年，Kim提出了克隆家系模型用于描述克隆代码的演化过程，被认为是迄今为止最好的演化模型，并已成为克隆演化分析的事实标准\cite{kim2005empirical}。其后，人们对克隆家系进行了大量的研究。例如Roy使用函数映射帮助构建克隆家系，并开发了gCad克隆家系提取器，大大提升了构建克隆家系的时间效率\cite{saha2011automatic}。Bakota通过映射不同版本的克隆来分析克隆代码的演化过程，并使用克隆坏味（Clone Smell）帮助分析克隆代码对系统的影响\cite{bakota2011tracking}。2009年，Harder对现有的演化模型进行分析\cite{harder2009modeling}，指出通过分析克隆演化特征可以帮助程序开发和维护人员理解和维护克隆代码。

究竟哪些演化特征能真实准确地反映克隆代码的规律？这是克隆演化分析的难点问题。因此目前对克隆演化分析的研究主要集中在研究确定提取克隆代码的哪些特征作为演化特征以及如何提取这些特征。目前，常用的克隆演化特征主要包括克隆寿命、克隆稳定性与一致性变化。

克隆寿命是指克隆代码在系统中的存在时间，即生存期。Kim研究发现克隆代码要比非克隆代码更加稳定，同时寿命也更长\cite{kim2005empirical}；进一步对长寿命的克隆代码进行研究后，发现对克隆代码的修改会使得克隆代码的寿命变短\cite{cai2011empirical}。Krinke通过对比克隆和非克隆代码，也发现克隆代码比非克隆代码的寿命更长\cite{krinke2011cloned}。通过对精确克隆和近似克隆的演化分析，发现其在演化过程中所表现出来的共同特点是：尽管克隆代码比率会随着时间而逐渐降低，但克隆代码的存在时间往往都会超过一年\cite{bazrafshan2012evolution}。因此，克隆代码会长时间的存在于系统中，在其生存期间克隆代码往往会发生变化，其变化规律与具体的软件系统相关\cite{gode2009evolution}。

相对于克隆寿命而言，克隆稳定性关注的是在克隆代码的生存期内是发生变化的问题。被研究者普遍认可的观点是寿命较长的克隆代码是稳定的\cite{krinke2008cloned}\cite{gode2011clone}\cite{harder2013cloned}，不会对系统造成不利的影响，也不会增加系统的维护成本。但是在克隆代码是否比非克隆代码更稳定这个问题上还存在一定的分歧。例如Gode研究发现大部分克隆是稳定的，不会发生变化\cite{gode2011frequency}。而Rahman的研究却发现克隆代码比非克隆代码更容易发生变化，是不稳定的\cite{rahman2014change}。Mondal给出了更为细致的分析结果，即Type 1、Type 2克隆是不稳定的，Type 3克隆是稳定的；并且发现克隆代码比非克隆代码的变化更分散，Type 3克隆比Type 1和Type 2克隆的变化更分散\cite{mondal2012comparative}\cite{mondal2012dispersion}。由此可见，在克隆代码的稳定性特征方面尚未达成共识，仍需要进一步研究。

克隆代码的变化包括一致性变化和不一致性变化。开发人员遗忘一致性变化将会引发相关的软件缺陷，如标识符重命名不一致性缺陷等，因此一致性变化也是克隆演化分析研究中需要关注的特征。 Gode的研究发现发生一致性变化的克隆代码占克隆代码的比例很小\cite{gode2011frequency}。Krinke的研究进一步发现发生一致性变化和不一致性变化的克隆代码比例大约各占一半，并且大部分发生不一致性变化的克隆代码在后续的演化过程中不会继续发生变化\cite{Krinke2007}。Mondal等人的研究发现发生一致性变化的克隆代码可能会导致延迟传播现象。延迟传播是指某一个克隆片段的变化没有立即传播到其所在的克隆组中，而在间隔一定数量的版本后传播，继续发生一致性变化。研究表明延迟传播在Type 3的克隆中出现的更为频繁，软件开发人员应该重点关注Type 3克隆代码的变化，以避免引入克隆代码相关的软件缺陷\cite{mondal2016comparative}。

\begin{table}[htbp]
\centering
\bicaption[characteristic]{}{克隆演化特征分析}{Table$\!$}{The analysis of clone evolutionary characteristic}\vspace{0.5em}\wuhao
\begin{tabularx}{0.9\textwidth}{llX}
\toprule[1.5pt]
文献&克隆模式、特征&结论\\
\midrule[1pt]
\cite{kim2005empirical}&	克隆寿命/一致性变化	&观察并分析克隆家系的寿命与一致性变化规律\\
\cite{cai2011empirical}&	克隆寿命&	克隆寿命与克隆修改次数、新增和减少有关\\
\cite{krinke2011cloned}&	克隆寿命&	克隆代码的寿命比非克隆的寿命更长\\
\cite{bazrafshan2012evolution}\cite{gode2009evolution}&	克隆比率/寿命/变化规律	&克隆比率会随时间降低，会存在超过一年，存在期间变化规律往往和具体系统相关\\
\cite{krinke2008cloned}&克隆稳定性&	克隆代码比非克隆代码更稳定\\
\cite{gode2011clone}\cite{harder2013cloned}&	克隆稳定性&	克隆代码十分的稳定\\
\cite{gode2011frequency}]&	克隆变化/一致性变化&	大部分克隆不会发生变化，而一致性变化会更少\\
\cite{rahman2014change}&	克隆稳定性&	克隆会比非克隆更容易发生变化\\
\cite{mondal2012comparative}\cite{mondal2012dispersion}&	克隆稳定性/变化分布&	Type 1、Type 2是不稳定的，Type 3是稳定的；发现克隆代码变化比非克隆更加分散，同时Type 3克隆比Type 1和Type 2更加分散\\
\cite{Krinke2007}&	一致性变化&	一半的变化是不一致变化，且发生不一致性变化后，在后续的时间内会保持这种变化(即一致性变化)\\
\cite{mondal2016comparative}&	延后传播&	Type 3更容易发生延后传播，并且也更容易导致缺陷\\
\bottomrule[1.5pt]
\end{tabularx}
\end{table}

表~\ref{characteristic}~列出了目前对克隆演化特征的研究情况。由表中可以看出，研究者较为关注的克隆演化特征是克隆寿命、克隆稳定性与一致性变化。上述三个特征并不是相互独立的，克隆寿命会受到稳定性和克隆变化的影响，同时克隆稳定性与克隆变化之间存在对立关系。对克隆演化分析的研究大多属于实证研究，往往会较多地依赖于具体被用于实验分析的软件系统，这就导致了不同的研究可能得出不同的结论。例如对克隆稳定性的研究就出现了截然相反的观点。尽管如此，克隆演化特征分析依然可以给开发人员提供有价值的建议。一个普遍的共识是在维护和管理克隆代码的过程中更应关注那些克隆寿命较短、稳定性较差、发生一致性变化的克隆代码。但克隆寿命、克隆稳定性和一致性变化之间究竟存在着怎样的关系，它们对软件质量究竟会产生怎样的影响，还有哪些影响软件质量的克隆代码特征，还有待进一步深入的研究。

\BiSubsubsection{克隆代码评价}
{Code Clone Evaluation}

克隆评价分析主要是分析克隆代码对系统产生的影响，以便辅助开发人员更好地理解和维护克隆代码。克隆代码是否有害一直是克隆评价关注的一个热点，也是争论的一个焦点问题。因此，克隆评价研究主要是围绕着克隆代码是否有害而展开的，只是在不同阶段，人们对克隆代码的态度有所不同，研究的关注点也因此有所不同而已。

在研究的初始阶段，人们大多倾向于认为克隆代码都是有害的，因而研究的侧重点是克隆代码是否会引发软件缺陷（即克隆代码相关的缺陷分析），以及克隆代码是否会增大系统的维护代价（即克隆代码的维护代价分析）。然而随着对克隆代码研究的深入，人们研究发现虽然克隆代码有时会对软件质量产生一些负面影响，但并不一定都是有害的，从而引发了对克隆代码有害性的讨论（即克隆代码的有害性分析）。因此，克隆评价主要包括克隆相关的缺陷分析、克隆维护代价分析、克隆有害性分析等。

在早期，有人认为克隆代码是一种最刺鼻的代码坏味，是因为它有可能会引发相关缺陷。因此，人们研究的关注点主要集中在克隆代码的缺陷分析上。例如，Juergens等人研究发现克隆代码的不一致性变化会引发相应的软件缺陷，从而降低了软件质量\cite{juergens2009code}。Gauthier通过对克隆代码进行安全性分析，在开源软件Joomla和Moodle中发现了几个潜在的影响软件质量的安全漏洞和缺陷\cite{gauthier2013uncovering}。但也有另外一些证据表明克隆代码的不一致性变化并不一定会引发缺陷，因此不会对软件质量产生显著的影响。例如，Bettenburg对不一致性变化是否引发缺陷的研究发现，仅有极少数的不一致性变化会引发缺陷\cite{bettenburg2009empirical}。文献\cite{wagner2016relationship}的研究则表明Type 3克隆代码中大约有17\%的代码含有缺陷，并且Type 3克隆不容易发生不一致性变化。文献\cite{elish2015fault}通过对缺陷密度的分析发现，面向对象程序中的克隆类含有更少的缺陷，并且Type 3克隆含有的缺陷最少。因此有人将克隆代码研究应用到缺陷检测中，但没有直接证据证明克隆代码与缺陷密切相关\cite{lo2012active}\cite{kamei2011empirical}。因此，克隆缺陷分析并不能直接证明克隆代码是有害的。

除了克隆相关的缺陷分析外，还可以从维护代价的角度去分析克隆代码对软件产生的影响。Harder通过实验发现克隆代码的存在并不会增加缺陷修复的时间，但是缺陷未被修复则可能导致维护代价的增加\cite{harder2012controlled}。Lozano通过研究克隆代码的可变性，也发现克隆代码的存在会增加软件维护的代价\cite{lozano2008assessing}。Juergens不仅认为克隆代码会增加维护代价，还提出了一个计算模型来计算克隆维护代价\cite{juergens2010much}。而Monden的研究则发现包含少量克隆代码的软件模块比不含克隆代码的软件模块更可靠，但含有大量克隆代码的软件模块则正相反，实验表明克隆代码与软件可靠性和维护代价有一定的关联，但这种关联关系并不十分明确\cite{monden2002software}。以上维护代价分析的研究表明克隆代码的存在有可能会增加软件的维护代价，但是如何定量地计算克隆代码引起的维护代价仍然是一个尚未解决的问题。

虽然缺陷分析和维护代价分析可用于评价克隆代码对软件产生的影响，但却不能作为评价克隆代码是否有害的直观证据。正因如此，近些年来，研究人员又展开了克隆代码有害性分析的研究。Kapser通过对比11种克隆模式在软件开发和维护过程中的优缺点，并在开源软件Apache和Gnumeric上进行实证研究，发现在Apache中大约有71\%的克隆代码被分类为有益克隆，对系统维护具有积极的影响，是一种合理的存在方式，因此人们应当正视在开发过程中克隆代码的长期存在\cite{kapser2006cloning}\cite{kapser2008cloning}。Kapser通过对Apache Web Server中的克隆代码进行分析，研究发现其中一个子系统中聚集了大量的克隆代码；该子系统的克隆代码增加了系统的功能性，对软件开发过程是有益的\cite{kapser2006supporting}。Selim使用风险模型判定克隆代码是否有害，研究结果发现克隆代码并不比非克隆代码具有更高的有害风险\cite{selim2010studying}。Wang提出利用贝叶斯网络对克隆代码进行有害性预测的方法\cite{wang2012can}，该方法可用于辅助开发人员决定是否可以通过复制粘贴的方式引入新的克隆代码。Higo则提出一种提取有问题的克隆代码（有害克隆）的方法，该方法先对程序进行标准化，然后利用检测工具检测克隆代码，最后对检测到的克隆代码进行过滤、合并等操作来提取有问题的克隆代码，在Linux内核2.6.6上的实验结果表明只有少数克隆代码是有问题的克隆代码\cite{higo2009problematic}。Hordijk提出了一个结构化的证据模型分析克隆代码的有害性，研究结果表明只有少部分的证据证明克隆代码是有害的，并且仍需更多的研究去支撑这一结论\cite{hordijk2009harmfulness}。从上述对克隆代码有害性分析的结果不难得出结论，克隆代码并非都是有害的，但是究竟具有什么特征的克隆代码是有害的，还是一个有待深入研究的问题。

\begin{table}[htbp]
\centering
\bicaption[evaluation]{}{克隆评价分析}{Table$\!$}{The analysis of clone evaluation}\vspace{0.5em}\wuhao
\begin{tabularx}{0.9\textwidth}{lllX}
\toprule[1.5pt]
&文献&评价&结论\\
\midrule[1pt]
\multirow{6}{*}{缺陷分析} 
&\cite{juergens2009code}&消极&研究发现不一致变化在克隆中发生较为频繁，同时也会导致相应的缺陷\\
&\cite{gauthier2013uncovering}&消极&通过对不安全的克隆代码分析，发现了几个安全漏洞和缺陷\\
&\cite{bettenburg2009empirical}&积极&克隆代码的不一致变化并不会引入缺陷，不会对软件的质量产生影响\\
&\cite{elish2015fault}&积极&克隆代码含有更少的缺陷，Type 3所含有的缺陷最少\\
&\cite{lo2012active}&中立&克隆代码研究应用到缺陷检测中，但没有直接证据证明与缺陷相关\\
&\cite{kamei2011empirical}&中立	&通过实验发现并不会增加缺陷修复时间，但是缺陷未被修复，可能会产生维护代价的增加\\
\midrule[1pt]
\multirow{4}{*}{维护代价} 
&\cite{wagner2016relationship}&中立	&Type 3克隆中有17\%含有缺陷，并且Type3克隆更容易发生一致性变化\\
&\cite{harder2012controlled}&消极&通过对克隆代码的可变性研究发现克隆代码确实会增加其方法可变化的维护代价，但没有确切的证明会说明克隆会增加系统维护代价\\
&\cite{juergens2010much}&消极&认为克隆会增加维护代价，并且提出了一个代价计算模型计算这次代价\\
&\cite{monden2002software}&中立&Monden却发现包含克隆的模块比不含克隆的模块更可靠，同时含有大量克隆的模块却相反实验表明了克隆与系统可靠性和维护代价的关系，但是这种关系仍然不够明朗\\
\midrule[1pt]
\multirow{6}{*}{有害性} 
&\cite{selim2010studying}&积极&克隆代码并不比非克隆代码具有更高的有害风险\\
&\cite{kapser2006cloning}\cite{kapser2008cloning}&积极	&发现最多有71\%的克隆对系统的可维护性具有积极的影响\\
&\cite{rahman2012clones}&积极	&克隆并不是真正的代码坏位，克隆是无害的\\
&\cite{wang2012can}&中立	&预测克隆有害性，其中有害的较少，无害的较多\\
&\cite{higo2009problematic}&中立&使用分类模型抽取有问题的克隆代码，只有少部分是有问题的克隆\\
&\cite{hordijk2009harmfulness}&中立&现有研究不能支撑克隆有害的观点，仍需进一步的研究\\
\bottomrule[1.5pt]
\end{tabularx}
\end{table}

表~\ref{evaluation}~对克隆评价分析研究进行了分类统计，使用"积极"、"中立"和"消极"三种评价标准对现有的克隆评价分析方法进行了总结。"积极"是指克隆代码的存在对系统有积极的影响；"中立"是指克隆代码不会对系统产生影响；"消极"是指克隆代码会对系统产生消极的影响。从表中可以看出，大部分研究对克隆代码持积极和中立的态度，仅有少数持消极态度。这从另外一个侧面表明目前对克隆代码是否有害还存在一定的分歧，主要原因是对克隆代码缺少统一的评价标准以及深入的特征挖掘与分析，当然这也是克隆评价分析中的最具挑战性的问题。

\BiSubsection{克隆维护和管理}{Code clone maintenance and management}

\BiSubsubsection{克隆维护}{Code clone maintenance}

克隆维护是解决克隆代码问题的直接途径，主动地解决克隆代码可能或已经引发的问题。克隆维护与软件开发过程结合得较为紧密，维护的方法主要包括克隆重构、克隆规避、克隆复用。

（1）克隆重构

重构作为一种常见的软件维护手段，是指在不改变软件外部行为的条件下改变软件的既有设计\cite{kerievsky2006重构与模式}。重构经常应用于克隆维护中，通过重构手段消除系统中的克隆代码。

由于重构所需的条件较为苛刻，同时重构的代价也较大，还需考虑重构安全的问题。因此，在重构前对克隆代码进行可重构性分析和重构排序显得尤为重要。可重构性分析旨在识别适于重构的克隆代码候选集合，以提高克隆重构的效率。Lin等人通过对克隆代码进行差异性分析，帮助开发人员决定是否进行重构操作和如何执行重构操作\cite{lin2014detecting}。Mende实现了一个工具支持可重构性分析，在软件中识别可以被重构的函数克隆\cite{mende2009evaluation}；Schulze提出了一个用于识别可重构的克隆代码的克隆分类方法，通过计算克隆代码的可重构指数识别可重构的克隆代码\cite{schulze2008towards}；Choi等人提出了基于度量值的可重构性分析方法，可以快速地识别可重构的克隆代码\cite{choi2011extracting}。识别可重构克隆后，为了节省重构时间，还可以对克隆代码进行重构排序或者调度。如Mandal先通过分析克隆演化模式来确定克隆候选，然后使用关联规则挖掘进行可重构排序、\cite{mandal2014automatic}；Lee采用遗传算法对重构进行调度，以确定重构顺序帮助改进软件质量\cite{lee2011automated}；Zibran提出一种极限编程方法对克隆代码进行重构调度\cite{zibran2011constraint}。另外，Liu等人提出了一个重构调度方法帮助优化调度过程\cite{liu2012schedule}。尽管该方法不是针对克隆重构的，但也可以考虑将其应用于克隆代码的重构调度上。此外，Radhika等人仅考虑重构代价对所有的克隆代码进行重构排序，未考虑克隆代码是否适合重构的问题\cite{venkatasubramanyam2013prioritizing}，应该结合可重构性分析指导克隆重构。
克隆重构最主要的目的是消除系统中的克隆代码。Higo等人开发了一个工具ARIES，根据克隆代码的结构信息识别可重构的克隆代码，然后通过计算不同的度量值来确定使用哪一种目前已有的重构方法移除克隆代码\cite{higo2008metric}。Krishnan通过分析克隆代码的程序依赖图，确定给定克隆代码能否被安全的重构，然后通过检测和参数化克隆代码的差异点对克隆代码进行重构，取得了较好的效果\cite{krishnan2014unification}。Barbosa使用四种规则重构克隆代码，并在开源软件JhotDraw上进行了实验，结果表明基于规则的重构方法可以有效地移除软件中的克隆代码\cite{barbosa2013removing}。

在重构完成后，对重构后代码进行分析，还可以得出一些结论以进一步指导克隆重构。G{\"o}de通过对维护人员使用的重构方法和被重构的克隆代码进行实证研究，发现在不同的软件系统中都存在克隆重构的行为，并且克隆重构不是经常性地发生而是有选择性地发生\cite{gode2010clone}。Zibran等人通过克隆重构研究，回答了所提出的关于克隆重构的七个研究问题，并且研究发现克隆规模对克隆重构没有重要的影响，同时在软件早期的版本中重构会较为频繁地发生，发生重构的克隆在重构前往往是较为稳定的克隆代码\cite{zibran2013evaluating}。Choi通过对重构行为进行观测，识别出几种较为频繁的克隆重构模式，并且分析了每种重构模式的特征，这些都有助于进一步指导克隆代码的重构\cite{eunjong2014investigation}。Tairas通过对克隆代码的重构性分析，提出了子克隆的概念，并研究发现子克隆的重构行为更容易发生，因此建议在对克隆代码的维护过程中应重点考虑子克隆的重构\cite{tairas2010sub}。

目前，虽然已有重构方法以插件的形式集成到了eclipse中 ，支持在软件开发过程对一般代码坏味重构。由于一般代码坏味的重构方法不一定适合克隆代重构，所以尚未有在软件开发环境中针对克隆代码的重构方法。此外，重构是在克隆代码出现后用以消除克隆代码的一种被动的软件维护方法，而且并非所有的克隆代码都适合重构，因此重构不是解决克隆代码维护难题的最有效的方法，更有效的方法是在软件开发过程中主动地规避或维护克隆代码，这是克隆维护中的一个难点问题。

（2）克隆规避

克隆规避也称克隆预防，是在克隆产生时通过某种策略或手段进行干预，以避免克隆代码的产生。克隆规避是一种预防性的克隆维护方法，通过阻止克隆代码产生来降低克隆维护的代价。

软件开发人员的复制粘贴活动是导致克隆代码产生的最主要原因。因此在复制粘贴时对新产生的克隆代码进行分析，帮助软件开发人员决定是否规避克隆代码，是目前常见的克隆规避方法。Ali曾提出一个克隆规避的概念模型\cite{ali2013enhancing}，尽管对克隆规避研究具有一定的指导意义，但并未给出该模型的具体实现方法。Wang等人基于贝叶斯网络在复制粘贴时预测克隆代码的一致性变化，通过判断一致性变化决定是否规避该新产生的克隆代码\cite{wang2012can}\cite{wang2014predicting}。Ravikanth通过分析复制粘贴操作的前置和后置条件，来确定是否允许对被复制的克隆代码实施粘贴操作，从而实现克隆规避\cite{venkatasubramanyam2012method}。

由于受软件复用的影响和编程语言的限制，大部分克隆代码是无法避免的。克隆规避可以作为一种辅助的手段通过限制开发人员在软件开发过程中的复制粘贴操作帮助减少克隆代码的产生，但却无法规避全部的克隆代码。在实际的应用中，还需要将克隆规避和克隆管理相结合，对可以规避的克隆代码采用规避技术进行主动地规避，对无法规避或者无需规避的克隆代码采用跟踪的方式进行管理，以主动地维护这些代码。

（3） 克隆复用

在软件开发过程中，复用既有代码是一种常见的软件开发手段。近些年来，随着对克隆代码评价分析研究的深入，人们已经意识到复用健壮性好的克隆代码不仅有助于缩短软件开发周期，还有利于提高软件的健壮性和可维护性。因此，对克隆复用的研究在近些年来引起了人们的关注，成为克隆代码领域中的一个新的研究方向。不过，相对于克隆检测和分析而言，目前对克隆复用的研究还相对较少。

Krutz等人提出克隆数据库概念，将已有克隆代码组织为克隆数据库，并结合代码检索技术实现对克隆代码的复用\cite{krutz2014code}。Ishihara提出的方法也允许开发人员通过代码搜索技术搜索可以复用的克隆代码\cite{ishihara2013reusing}。Ohta通过对比软件开发过程中由复制粘贴操作产生的克隆代码和系统中已存在的克隆代码，并将该克隆代码划分为较差、较好、最好三种情况，辅助开发人员决定是否能够复用该克隆代码\cite{ohta2015source}。但该方法对克隆代码的可复用性评价仅依赖于开发人员的复制粘贴操作，仅在复制粘贴操作发生后给出可复用性建议，无法在复制粘贴操作发生前为开发人员提供可复用的克隆代码信息。在软件开发过程中直接向开发人员提供一个已经通过某种评价方式确定是否可复用的克隆代码库，是一种更为主动的克隆代码复用形式。例如，Yang\cite{yang2015classification}等人使用机器学习模型对克隆代码进行分类，分类标准由开发人员动态地标记，通过标记可复用的克隆代码将该方法应用于克隆复用，辅助开发人员搜索可以复用的克隆代码。Ohtani从代码建议的视角辅助开发人员复用已有的代码，从不同粒度（关键字级别、方法级别和混合方法）对可复用的代码提供搜索支持，实验结果表明混合方法可以更精确地提供代码是否可复用的建议\cite{ohtani2015level}。Kintab实现了一个克隆代码的专家推荐系统，可以在线向软件开发人员提供复用克隆代码的相关咨询，软件开发人员可以根据专家的建议决定如何复用和维护既有的克隆代码\cite{kintab2014recommending}。

软件复用在提高软件开发效率的同时，势必也导致产生大量的克隆代码，这就使得克隆复用研究面临着一些新的问题。例如，如何实时地跟踪、维护和管理一个可复用的克隆代码库，在保证软件开发质量的前提下，主动地复用既有代码，以提高软件开发效率，既是一个新问题，也是一个难点问题。

现有的克隆代码复用研究大都是针对单一项目的。如何实现对跨项目的克隆代码复用是克隆复用面临的另一个新问题。目前，在互联网环境下，大量的开源社区里也普遍存在代码复用的情况，由此产生了跨项目的克隆代码和对跨项目代码复用的应用需求。但目前对这种跨项目的克隆代码复用的研究依然较少。Ishihara对跨项目的软件进行函数克隆检测，试图建立一个公用函数库用于代码复用\cite{ishihara2012inter}。Cheng等人研究了跨项目的克隆代码检测技术\cite{cheng2016feasibility}。Tairas等人将信息检索技术与克隆代码分析相结合，以便快速有效地搜索可复用的克隆代码\cite{tairas2009information}。事实上，以上这些技术都可以用于跨项目的克隆代码搜索和复用中。

\BiSubsubsection{克隆管理}{Code clone management}

克隆代码的重构是在克隆代码产生之后消除克隆代码及其对系统产生的影响，这种维护方式属于一种较为被动的维护方式，其维护代价本来就较高。而克隆代码往往又会随时间的推移和需求的变更而在软件系统中发生变化或者产生新的克隆代码，频繁地重构势必进一步增大克隆代码维护的代价。如果将克隆代码的维护提前到软件开发阶段，在软件开发过程中跟踪克隆代码的变化，并主动地规避克隆代码的产生，则势必会降低后期维护的代价。而若要实现这种主动的维护方式，则需要从克隆代码管理的角度解决克隆代码的维护难题，即通过在软件开发过程中实现边开发、边管理克隆代码，以主动的方式维护克隆代码，消除克隆代码对软件系统的不利影响。

克隆代码管理（简称克隆管理）的概念最早是1997年由Koschke提出的\cite{koschke2008frontiers}，但当时并未引起人们的重视。随着克隆代码规模的逐渐增大，人们发现现有手段无法有效解决克隆代码维护难的问题时，才开始把目光重新转向对克隆管理的研究。

目前克隆管理被认为是解决克隆代码维护难题的最有效的方式。早在2012年的面向工业界的克隆管理会议（Software Clone Management Towards Industrial Application）中，就有专家学者指出克隆管理是未来的重要研究方向，如何将克隆管理与软件开发过程相结合并使之适用于工业界是目前克隆研究领域急需解决的问题\cite{koschke2012software}。但是目前人们对克隆管理的研究仍处于起步和理论研究阶段，罕有从管理的角度维护克隆代码的研究报道。

Koschke将克隆管理划分为预防性、补偿性和改正性三种类型\cite{koschke2008frontiers}。预防性克隆管理的目标是避免克隆代码，关注于避免新的克隆代码的产生，而不是对已有克隆代码的管理。补偿性克隆管理的目标是发现克隆代码所引发的问题，并对其对系统造成的不利影响进行补偿。改正性克隆管理的目标是以主动的方式消除可能对系统产生不利影响的克隆代码。然而，Koschke对克隆管理的这种划分方法的理论意义大于实际意义。目前克隆管理研究主要集中于补偿性克隆管理，而改正性克隆管理尚未具体应用到实际的克隆管理中。

Roy在文献\cite{roy2014vision}中对克隆管理研究进行了详尽的阐述，指出目前对克隆管理的研究依然较少，尚缺少有效的克隆管理方法，尤其是对Type 3和Type 4克隆代码进行管理的研究还不够充分，未来应针对这两种类型的克隆代码的管理进行深入研究。尽管Roy对克隆管理的分析涵盖了克隆代码领域的大多数研究内容，但只是以工作流的形式组织这些研究内容，并未考虑这些研究内容之间的联系，彼此之间的信息是相互割裂的，同时也没有结合软件开发过程分析对克隆管理的要求，更没有给出具体的克隆管理方法

克隆代码管理的主要目的是降低克隆代码维护的代价。目前克隆管理的研究内容主要包括克隆跟踪、克隆变化管理以及克隆管理工具。其中，克隆跟踪是研究跟踪克隆代码产生和变化的方法。克隆变化管理是研究对克隆代码的变化进行管理的方法。克隆管理工具是研究开发有效管理克隆代码的工具。

克隆管理需要解决的首要问题是如何实时地跟踪系统中的克隆代码，包括克隆代码的产生及其变化。由于复制粘贴操作是导致克隆产生的主要原因，因此对克隆跟踪的研究主要是通过监测程序员的复制粘贴操作来实现的。例如，许多克隆跟踪工具CLONEBOARD\cite{de2009managing}、CnP\cite{hou2009cnp}、CPC\cite{weckerle2008cpc}、CReN\cite{jablonski2007cren}、CSeR\cite{jacob2010actively}等都是在软件集成开发环境中跟踪克隆代码的产生，但并非都能跟踪克隆代码的变化。另一方面，在软件开发过程中克隆代码可能随时发生变化，因此要实现对克隆代码的管理，不仅要跟踪克隆代码的产生，还要跟踪克隆代码的变化。Duala使用克隆区域描述符描述生成克隆代码的上下文信息，然后根据这些上下文信息实时跟踪克隆代码的变化\cite{duala2008clonetracker}\cite{duala2010clone}。该方法仅通过实验验证可以跟踪克隆代码的变化，但是并没有实现可用的插件集成到集成开发环境中，以实现对克隆代码的边开发、边管理。

跟踪克隆代码的目的是为了对克隆代码进行维护和管理。为了实现边开发、边管理克隆代码，还要对克隆代码的变化进行维护和管理。Yamanaka等人\cite{yamanaka2013applying}将克隆变化与事件通知机制相结合，将每一个克隆变化都看成一个事件，在克隆发生变化时提醒开发人员及时地对克隆变化进行维护。Cheng等人\cite{cheng2016rule}提出了一个基于Token的克隆代码一致性维护方法，当克隆组内的一个代码发生变化时，能够同时修改组内的其他克隆代码，保证克隆代码的一致性。该方法的前提是已知克隆变化需要一致性维护，但没有给出克隆变化是否需要一致性维护的判定方法。因此，Zhang等人\cite{zhang2016predicting}在克隆代码发生变化时预测克隆代码一致性维护需求。该方法通过提取克隆代码的演化信息及其相关特征，在克隆代码发生变化时辅助开发人员确定克隆变化是否需要一致性维护。Mondal等人通过对克隆组内的克隆代码排序，从而预测需要一致性维护的克隆代码\cite{mondal2014prediction}。此外，Murakami等人在克隆代码未发生变化时，预测克隆代码的下一次变化\cite{murakami2014predicting}。该方法通过分析历史版本中的克隆代码的变化情况，提取相关的特征进行变化预测，以便在软件开发过程中提醒开发人员对有可能发生变化的克隆代码进行维护。可见，克隆变化管理的关键不仅需要实时跟踪克隆代码的变化，更重要的是对发生变化的克隆代码进行及时的维护。

前面的研究只是针对不同的侧重点提出的克隆管理方法，却没有提供可以实际应用的克隆管理工具。鉴于此，Zhang基于事件通知机制实现了一个克隆管理工具，不仅可以监测克隆代码的产生，还可以监测克隆代码的维护过程\cite{zhang2013towards}。Nguyen实现了一种可用于管理克隆代码的eclipse插件JSync\cite{nguyen2012clone}。该插件支持在软件开发过程中对克隆代码进行克隆关系管理和一致性维护管理。这里的克隆关系管理是指在软件开发过程中检测系统中的克隆代码，并对具有克隆关系的代码进行管理。这里的一致性维护管理是指识别变化的克隆代码以及变化的克隆代码是否会导致不一致性缺陷，以便开发人员对克隆代码进行一致性维护。而另一个较早提出的eclipse插件CeDAR\cite{tairas2012increasing}。虽然没有强调是一种克隆管理工具，但事实上也具有一定的克隆管理功能。该插件将克隆检测和克隆重构融为一体，对现有克隆检测工具的克隆检测结果进行可重构性分析，寻找潜在的可重构的克隆代码，然后在软件开发过程中实现对克隆代码的重构。

如何将克隆代码的检测、分析和维护结合到软件开发过程中，以实现对克隆代码的边开发、边维护和边管理是克隆管理急需解决的一个难点问题。

\BiSubsection{当前研究中存在的问题分析}{Problems in Current Research}

当前的克隆代码研究集中在了克隆检测、克隆分析和克隆维护与管理上。尽管已经具备了相当丰富的研究成果，但是也存在一些尚未解决完善的问题。

在克隆分析的研究中，克隆代码演化研究和克隆代码评价研究是主要的研究内容。同时克隆评价研究往往也是在克隆代码演化的基础上进行的，尤其是体现在演化过程的克隆代码变化对软件的影响。但是，上述研究中仍存在一定的不足之处。首先最重要的是，克隆代码演化研究中研究人员的研究集中到某一个克隆代码的特征上，并没有从整体的对克隆代码进行分析，例如研究了克隆代码的变化性、延后传播、克隆寿命等某一个具体的问题。其次，克隆评价分析也无法达到统一的结论，现有的研究的目的性较为主观，往往是通过分析现有的实验系统从而达到一个特定的目的，例如有害性分析、维护代价分析和缺陷分析等。这对于从细节上把握克隆代码的研究有一定的帮助作用，但是也无法从整体上帮助理解克隆代码及其演化特征。因此，如何从大量的克隆代码及其演化过程中识别克隆代码的演化特征，从而帮助理解克隆代码，并进一步的帮助克隆分析的研究，是一个值得研究的问题。


在克隆维护和管理中，研究人员进行了大量的研究，包括对克隆代码的重构、克隆复用和克隆管理。上述研究的根本原因在于试图解决或者避免克隆代码对系统产生的不利影响。尤其是近几年被广大研究人员所热衷的克隆代码管理研究，试图从管理的角度彻底解决克隆代码问题。然而，克隆代码对软件所产生的最重要的影响是克隆的变化，尤其是克隆代码的一致性变化、不一致变化及其由此多引发的克隆缺陷和额外的维护代价。如何避免、解决克隆代码的一致性问题是实现克隆代码维护和管理的一个值得研究的问题。

\BiSection{研究内容与论文结构}{Main research contents and structure of this dissertation}

\BiSubsection{研究内容}{Main research contents}

本文通过结合软件演化过程、机器学习和程序分析方法，研究基于机器学习的克隆代码分析和维护方法，首先针对克隆代码的演化特征进行分析，旨在解决以下四个研究内容。

首先，克隆代码随着软件系统的演化同时演化，在其演化过程中所表现出的特征称之为克隆演化特征，克隆演化特征对理解和维护克隆代码有极为重要的意义。本文结合机器学习方法，提取相应的度量值对克隆代码进行演化特征分析，获取相应的克隆代码演化特征，帮助理解和维护克隆代码。

然后，在演化过程中，克隆代码的一致性维护问题是影响软件质量的一个重要因素。克隆代码的一致性变化问题可能会导致新的克隆缺陷，而保持这种一致性也会导致克隆代码的维护代价变大，因此研究克隆代码的一致性维护需求预测显得尤为重要，本文结合机器学习方法，在克隆代码产生和变化之时，分别对其进行一致性维护需求预测，从而避免引入和克隆代码相关的额外维护代价。

最后，\emph{为帮助程序开发人员选择相应的机器学习方法和预测时间，从而更高效的避免克隆缺陷、降低维护代价。克隆代码的一致性变化深深影响着软件质量，对克隆代码的一致性变化提供支持，实现克隆代码的一致性维护，可以帮助维护克隆代码，避免引入由于变化导致的克隆一致性缺陷。}

论文通过对克隆代码的演化特征分析，发现克隆代码一致性问题是影响软件质量原因。通过在复制粘贴和代码变化之时预测克隆代码的一致性维护需求，帮助避免克隆所产生的额外维护代价。\emph{通过对克隆代码的一致性维护实现对克隆代码变化的自动维护，提高系统的可维护性和软件质量。}


主要包括以下四个研究内容：

（1）克隆代码随着系统的演化而演化，在克隆代码及其演化过程中必然隐含了一定的规律和信息，如何揭示隐藏在克隆代码及其演化过程中的克隆代码特征，帮助软件开发和维护人员充分理解和分析克隆代码？ \\

在软件中存在大量克隆代码，我们使用当前的克隆检测工具可以检测系统中大量克隆代码。尽管我们可以检测克隆代码，但是这些克隆代码是否隐藏了一些信息，如何获取这些信息是值得研究的一个问题。同时，克隆代码并不是静态的，是随着软件系统演化而演化。目前对于克隆代码的演化过程和演化模式也有比较深入的研究，但是对克隆演化的研究都集中在克隆演化过程和克隆模式上，演化过程和演化模式中是否存在特定的结论，我们称其为克隆演化特征。克隆代码演化特征是在克隆代码及其演化过程中，所包含或所隐藏的有助于理解和维护克隆代码的一些指导性结论。因此，如何结合克隆演化过程和克隆演化模式，揭示软件中的克隆演化特征，并用于指导克隆代码维护是一个值得研究的问题。\\

（2）如何在复制和粘贴之时快速有效的识别出系统中的可能需要一致性维护的克隆代码，并在复制粘贴之时避免此类克隆代码的产生或者复用不需要维护的克隆代码，从而帮助降低软件的维护代价？\\

系统中存在大量的克隆代码，并且克隆也随系统演化而演化。在这些克隆代码中，存在相当数量的经常发生变化的克隆代码，尤其是发生一致性变化的克隆代码。克隆代码的一致性变化会对软件产生深远的影响，如会引发额外的维护代价，于此同时遗忘这种变化会引入额外的维护代价。因此，如何在克隆代码产生之时即复制粘贴时，预测此克隆代码在未来演化中是否会发生一致性变化是值得研究的问题。即在复制粘贴时预测克隆代码的一致性维护需求仍是一个值得研究问题。在复制粘贴之时预测该克隆代码的一致性维护需求，可以用于克隆代码的预防和避免中。如果其需要一致性维护需求，则不允许该克隆代码的产生，从而可以减少克隆代码导致的维护代价，也可以避免一致性缺陷。同时，在复制粘贴之时预测该克隆代码的一致性维护需求，还可以用于帮助快速开发软件系统，保证软件质量。如果其不需要一致性维护需求，则程序开发人员可以放心大胆的复用该克隆代码，可以提高软件开发速度，同时因为不需要一致性维护也可以提高代码质量。\\

（3）如何在克隆代码发生变化之时，快速有效的预测同组克隆代码是否同时需要发生一致性变化，并在发生变化时提示维护人员对克隆代码进行一致性维护，从而避免引入与之相关的一致性缺陷？\\

系统中存在大量的克隆代码，并且克隆也随系统演化而演化。在这些克隆代码中，存在相当数量的经常发生变化的克隆代码，尤其是发生一致性变化的克隆代码。克隆代码的一致性变化会对软件产生深远的影响，如会引发额外的维护代价，于此同时遗忘这种变化会引入额外的维护代价。因此，如何在克隆代码发生变化之时，预测同组的克隆代码在未来演化中是否会发生一致性变化是值得研究的问题。即在克隆代码变化之时预测同组克隆代码的一致性维护需求是一个值得研究问题。当克隆代码发生变化时，往往同时需要确认同组的克隆代码中是否需要同样的变化，即一致性变化。确认这种变化需求会增加软件的维护代价，维护人员需要花费大量的时间对其进行分析。同时，对于需要一致性维护的克隆代码，遗忘这种一致性维护会直接导致一致性缺陷的产生，将大大降低软件质量，进一步增加软件的维护代价。\\

（4）如何结合软件开发过程对克隆代码进行一致性维护需求预测，克隆代码的一致性需求预测方法能否应用到其它的机器学习方法中，从而更加有效地帮助维护人员维护克隆代码的一致性，从而提高软件的可维护性并降低引入一致性缺陷的可能性？\\

在机器学习领域存在较多的机器学习方法（重新写啊）克隆代码的变化往往是系统中存在大量的克隆代码，并且克隆也随系统演化而演化。在这些克隆代码中，大部分的克隆代码是静止不变的。但同时存在相当数量的经常发生变化的克隆代码，尤其是发生一致性变化的克隆代码。克隆代码的一致性变化会引发额外的维护代价，维护人员需要对同组的克隆代码进行反复确认所发生的变化，同时还要主动且人工的对其进行一致性的维护。这一过程会花费维护人员的大量时间，与此同时人工的确认和维护还容易引发更多的缺陷，将会进一步的导致维护代价的增大。因此，如何在克隆代码发生变化之时，对需要一致性的克隆代码，对其进行自动地一致性变化维护是值得研究的问题。即在克隆代码变化之时对同组克隆代码进行一致性维护是一个值得研究问题。自动地对发生变化的克隆代码进行一致性维护，可以大大地降低软件的维护代价，并同时可以减少一致性缺陷的引入。同时，该方法可以切实的与软件开发环境相结合，在开发过程中实现对克隆代码的维护。

\BiSubsection{论文结构}
{Structure of this dissertation}cc
基于演化的克隆代码分析与维护方法，综合考虑软件演化、机器学习和程序分析方法实现对克隆代码的分析和维护。为了进一步说明本文的研究内容以及各个部分之间的关系，本文给出本文主要研究思路如图所示研究思路如图~\ref{framework}~3-1所示。克隆代码随着软件系统的演化同时演化，在其演化过程中所表现出的特征称之为克隆演化特征。克隆演化特征对理解和维护克隆代码有极为重要的意义，本文结合机器学习方法，首先，提取相应的度量值对克隆代码进行演化特征分析。在演化过程中，克隆代码的一致性维护问题是影响软件质量的一个重要因素，因此进而研究克隆代码的一致性维护需求。然后，在克隆代码产生和变化之时，分别对其进行一致性维护需求预测，从而避免引入和克隆代码相关的额外维护代价。最后，克隆代码的一致性变化深深影响着软件质量，对克隆代码的一致性变化提供支持，实现克隆代码的一致性维护，可以帮助维护克隆代码，避免引入由于变化导致的克隆一致性缺陷。

\begin{figure}[htbp]
\centering
\includegraphics[width = 0.8\textwidth]{Fig1-1framework.pdf}
\bicaption[framework]{}{打高尔夫球的人}{Fig.$\!$}{The person playing golf}\vspace{-1em}
\end{figure}

第2章研究基于聚类的克隆代码演化特征分析方法。将研究基于聚类的克隆代码演化特征分析方法，克隆代码演化特征是在克隆代码及其演化过程中，所包含或所隐藏的有助于理解和维护克隆代码的一些指导性结论。本文将使用机器学习方法对克隆代码、克隆组和克隆家系进行聚类，并根据聚类结果分析克隆演化特征，帮助理解克隆代码并指导克隆代码维护。基于聚类的克隆代码演化特征分析研究包含两个子任务：本文为了表示克隆代码信息，也为了更方便对克隆代码进行聚类，本文使用克隆度量表示克隆代码及其演化过程，提取了克隆代码度量值（静态度量和演化度量），根据实验结果并对克隆代码度量进行优选是克隆度量更好地表征克隆代码和演化过程。静态度量是指仅通过单一版本的分析即可提取的克隆代码特征，演化度量表示了克隆代码在演化过程中的变化情况。研究基于聚类的克隆代码演化特征提取方法
不同粒度的克隆代码及其演化过程会隐藏不同克隆演化特征，因此对克隆代码的演化特征提取将分成这三个粒度进行：克隆代码片段、克隆组以及克隆家系。对克隆片段聚类是将每个单独的克隆代码作为一个个体进行聚类；对克隆组聚类是对所有克隆组进行聚类；对克隆家系将对系统中所有克隆的演化过程等聚类分析。

第3章研究基于贝叶斯网络的克隆代码复制粘贴时的一致性维护需求预测

第4章研究基于贝叶斯网络的克隆代码变化时的一致性维护需求预测

第5章研究基于机器学习的克隆代码一致性维护需求预测实证分析

