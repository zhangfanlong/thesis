% !Mode:: "TeX:UTF-8" 

\BiChapter{绪论}{Introduction}

\BiSection{课题背景}{Background}

%本课题来源于国家自然科学基金面上项目“无定型克隆代码的检测与重构方法”（批准号：61173021）。

随着计算机软件广泛应用于经济、军事、商业等各个领域中，软件质量问题日益得到人们的广泛重视。保证软件高质量，并提高软件可维护性、可理解性已经成为系统开发和维护工作的一个不可或缺的重要方面。然而，随着需求和应用环境的不断变化，现实世界的软件系统也随着时间在不断演化，软件规模越来越大、逻辑越来越复杂，软件的质量、可维护性和可理解性会逐渐下降。

软件复用是软件开发人员常用的一种系统开发手段，软件复用提高了系统开发的效率，但同时也造成软件中大量的克隆代码。有研究表明，软件工程实践中可能产生多种类型的克隆代码，克隆代码在大型软件系统中约占代码总量的7-23\%。随着时间的推移和系统功能的不断添加，软件代码规模越来越大，程序结构越来越复杂，程序中的克隆代码也会越来越多，在系统复用已有代码的同时难免会在系统中引入缺陷，这就增加了系统维护的成本和难度，降低了软件的可理解性。有研究表明，当前影响软件质量、可维护性和可理解性的一个主要因素是软件中存在的大量的克隆代码。因此，如何理解和分析系统中既有的克隆代码，并且有效的维护管理系统中的克隆代码是一个值得研究的问题。对克隆代码的分析和维护研究，可以有效降低克隆代码对软件质量的影响，已成为目前软件工程领域亟待解决的一个问题。

\BiSection{研究目的与意义}{Objective and significance}
克隆代码的存在会对软件系统造成不可避免的影响，针对大型软件系统对软件可靠性要求较高的实际应用背景和需求。研究人员开展了大量且较为深入的克隆代码的研究，已经取得了较多的成果。当前对克隆代码的研究可分为三个主要的研究活动，即克隆代码检测、克隆代码分析和克隆代码维护。在当前对克隆的研究活动中，克隆代码的检测是最主要的研究活动，也是软件开发和维护领域中的一项重要任务。到目前为止，已经研究和开发出许多克隆代码检测的方法和工具，可以一定程度上识别系统中存在的多种类型的克隆代码。但由于克隆代码大量存在并且情况复杂，克隆检测结果并不是完全令人满意的。当前方法对于近似克隆代码检测效果并不好，同时无法完整的检测系统四型克隆。更令人值得注意的是，克隆代码检测的研究无法消除克隆代码对软件的不利影响，仅可以帮助无法直接帮助提高软件的质量以及可维护性。因此，克隆分析和克隆维护的研究可以更好地弥补这一不足之处。

因此，本课题通过对克隆代码的分析和维护研究，帮助维护人员理解和维护软件系统中的克隆代码，可以提高软件质量、软件可理解性和可维护性。克隆分析是当前对克隆代码研究的一项重要活动，是对既有克隆代码的分析活动，可以帮助程序人员理解克隆代码。经研究发现克隆代码是会随着软件演化而演化，在其演化过程中克隆代码会对软件系统产生影响，同时也表现出了不同的特征。因此，克隆代码分析可以对克隆代码的维护起到一定的帮助作用。但是当前对克隆分析研究也存在一定的不足之处。如何更深入的分析克隆代码，从而揭示克隆代码所隐含的信息，提取并提炼克隆代码的演化特征？因此，本课题通过克隆代码的演化分析，获取了克隆代码的演化特征，对于维护人员理解克隆代码，理解克隆代码的演化过程以及变化情况都具有积极的意义。

于此同时，克隆维护研究也是克隆研究的一项重要活动。克隆重构是消除克隆代码的重要途径，已有一些法和工具可以帮助实现克隆消除。但重构也不能完全解决克隆代码问题，满足重构条件的克隆代码占极小一部分。同时，对系统中存在的大量克隆代码，有相当数量的会频繁的发生变化。这些变化的克隆代码可能需要一致性的维护，而遗忘这种维护也会导致缺陷的引入。如何识别和判断需要一致性的克隆代码以及如何自动地支持该一致性的维护也是值得研究的问题。因此，本课题通过预测克隆代码的一致性维护需求，识别此类需要维护的克隆代码；并提供自动地维护克隆代码一致性的方法，帮助维护人员维护克隆代码的一致性。

%问题分析：
当前的克隆代码问题，深深困扰着

基于以上分析，本项目针对大型软件系统对软件可靠性要求较高的实际应用背景和需求，研究基于演化的克隆代码分析与维护方案，实现对演化克隆的分析和维护。本课题将结合克隆检测和克隆演化的研究成果，重点研究克隆代码演化特征分析，揭示软件系统的克隆代码隐含的信息；并对克隆代码的一致性维护需求进行预测，分别预测在复制粘贴之时和代码变化之时克隆代码的一致性维护需求；针对克隆代码的一致性变化问题，重点研究克隆代码的一致性维护方法，从而实现对克隆代码的分析和维护。本课题对于提高软件质量，使软件更易于理解和维护，不仅具有重要的科学理论意义，还具有重要的实际应用价值。


\BiSection{国内外研究现状及发展动态分析}{Related work}

克隆代码（简称克隆）是软件中彼此相似的代码片段[1]。导致克隆代码产生的原因是多种多样的，最常见的形式是通过复制粘贴操作复用已有的代码。研究结果表明系统中通常存在着大量的克隆代码，比其例大约在为7~23\%左右，有的甚至高达59\%[2]。长期存在于系统中的克隆代码，不仅影响着系统的可维护性，也影响着系统的可理解性。因此，对克隆代码的维护需求引发了一系列关于克隆代码的研究，包括克隆检测、克隆分析、克隆维护和克隆管理等。


克隆检测是被克隆代码领域研究最早也是研究最为充分的一个研究内容，许多克隆检测方法和工具被相继提出，如NiCad[3]、CCFinder[4]等。按照所使用的检测技术，可划分为基于Text、基于Token、基于Tree、基于Graph和基于Metric的检测方法。不同的方法适合检测不同类型的克隆代码，目前尚没有一种检测方法能够检测出系统中所有的克隆代码，尤其是语法相似的和语义相似的克隆代码。更重要的是从系统中检测出克隆代码并不是克隆研究的最终目的，还需要对克隆代码进行分析，如克隆代码产生的原因及其对系统产生的不利影响等，从而辅助开发人员理解、维护和管理克隆代码。因此，克隆检测仅仅是克隆代码研究的初级阶段。

克隆检测是指从软件中检测并报告克隆代码的位置的研究。相对于克隆代码研究的其他技术而言，克隆检测技术相对成熟。

\BiSubsubsection{克隆检测方法}{Related work}

一般而言，克隆代码检测分为三个步骤：代码的中间表示、相似性匹配和报告检测结果。首先使用不同的方法对源代码进行抽象表示或转换，将其表示为抽象语法树等中间表示形式。然后对代码的中间表示形式进行相似性匹配，寻找相似的代码片段。最后报告检测结果，将彼此相似的克隆代码以克隆组的形式保存在检测结果中。迄今为止，研究人员已提出许多种克隆检测方法，并开发了相应的检测工具。根据所使用的技术不同，可以将克隆检测划分为基于文本(Text)的方法、基于Token的方法、基于树(如Abstract Syntax Tree，AST)的方法、基于程序依赖图（Program Dependency Graph, PDG）的方法和基于度量值（Metric）的方法。

基于Text的克隆检测方法是通过直接比较源代码文本，使用字符串匹配等算法来检测克隆代码。因其并没有对源程序进行词法分析，大部分仅可以较好地支持Type 1克隆的检测，对其余类型克隆的支持较弱。目前使用较多的基于文本的克隆检测工具主要有duploc[33]、Simian[34]、DuDe[35]、SDD[36]、NiCad[3]等。
基于Token的克隆检测方法是通过对源代码进行词法分析，获得源代码的Token序列，然后通过寻找Token序列中相似的子序列来检测克隆代码。因其对源代码进行了词法分析，所以可以较好地检测Type 2克隆代码的检测。但由于缺乏必要的语法和语义分析，使其无法较好地支持Type 3和Type 4克隆的检测。目前使用较多的基于Token的克隆检测工具主要有Dup[37]、CCFinder[4]、CPMiner[38]、iClone[26]等。
基于Tree的克隆检测方法是将源代码表示为某种树的形式（如抽象语法树、代码解析树等），然后通过使用子树匹配算法从中寻找相似的子树来检测克隆代码。因其对源代码进行了语法分析，所以提高了克隆代码检测的准确率，尤其是可以较好地支持Type 3克隆的检测。但是由于子树匹配算法的时间复杂度高于前两种方法，因此这类算法的检测速度低于前两种方法。目前使用较多的基于Tree的克隆检测工具有CloneDr[39]、SimScan[27]、Deckard[28]、CloneDigger[40]等。
前三种克隆检测方法中所使用的中间表示形式较为容易实现，可使用程序静态分析方法或者编译器前端获得源代码的中间表示。大部分的克隆检测方法和检测工具属于前三种方法中的一种，可以检测系统中的大部分克隆代码。
基于PDG的克隆检测方法的主要思路是，将源代码转化成程序依赖图(包括数据依赖图和控制依赖图)，然后通过寻找同构的子图来检测克隆代码。因程序依赖图表示了程序的语义信息，所以该方法可以支持语义相似的Type 4克隆代码的检测。但由于程序依赖图生成算法和图匹配算法的时间和空间复杂度极高，因而导致这类检测算法的时空开销过大，使其无法应用于大规模程序的克隆代码检测。目前基于PDG的克隆检测工具主要有Duplix[41]等。
基于Metric的克隆检测方法是先将源代码转换为某种中间表示，然后在其基础上提取度量值并抽象为一个特征向量，然后通过计算特征向量的相似度来检测克隆代码。该方法的主要优点是检测速度快。但因基于度量值的方法高度依赖于度量值的提取，在对源码提取度量值的过程中会损失源码的部分语义信息，因此检测效果不够理想，使其应用受限。
此外，还有人使用结合两种或两种以上检测技术的混合方法来检测克隆代码。例如，Deckard在生成抽象语法树的基础上提取结构特征向量表示代码，然后使用聚类的方法寻找克隆代码[29]。CloneMiner先将源代码表示为Token形式，然后在此基础上通过使用频繁模式挖掘算法寻找相似模式来检测克隆代码[24]。

\BiSubsubsection{克隆检测评估}{Related work}

不同的克隆检测方法和检测工具各有其优缺点，分别适合检测不同类型的克隆代码，对同一类型的克隆代码的检测效果也不尽相同。如何针对具体的应用，选择合适的克隆检测方法和工具是困扰开发人员的一个问题。因此，研究人员对主流的克隆检测方法及其检测工具进行了评估研究，以期为用户选择方法和工具提供指导性的建议。Bellon对6个克隆检测工具进行了评估，分别对比了查准率、查全率以及时间和空间等性能[45]。Rattan通过使用一种标准的系统文献综述方法，详细分析了克隆检测方面的213篇文献，并对不同的检测方法进行了评估分析，并给出了未来的研究方向[46]。此外，Svajlenko重点分析了检测工具的使用技术和适用环境，对克隆检测工具的检测效果进行了详细的对比，对帮助用户选择和使用克隆检测工具有重要的指导意义[47]。
本文也对目前较为主流的克隆检测工具和方法支持的克隆类型和检测效果等进行了评估，评估结果如表1所示。其中，检测效果采用“较好”、“一般”和“较差”三种级别来评估：“较好”是指可以较好地支持该类型克隆代码；“一般”是指可以支持检测该类型克隆代码，但效果不佳；“较差”是指可以检测少部分的该类型克隆代码；对未支持的克隆类型未列出。
从表1可以看出，基于Text的检测工具不支持Type 4克隆的检测。对Type 1克隆的检测效果最好，对Type 3克隆的检测效果一般。而对Type 2克隆支持较弱，仅有两个工具可以支持。原因是Type 2克隆是标识符重命名的克隆代码，基于Text的方法不能很好地处理标识符重命名问题。基于Token的检测工具同样不支持Type 4克隆的检测，但是可以较好地检测Type 1和Type 2克隆。支持Type 2克隆检测的原因是在将源程序转换成Token序列时进行了词法分析，因此可以解决标识符重命名的问题。但仅有一个工具可以检测Type 3克隆代码，并且检测效果一般。基于Tree的检测工具，同样不支持Type 4克隆的检测，但是对Type 1克隆的检测效果较好，并且几乎都支持Type 2和Type 3克隆的检测。由于采用的匹配算法不同，对Type 3即近似克隆的检测效果不尽相同，有些可以较好地支持Type 2克隆的检测，有些则较好地支持Type 3克隆的检测。基于PDG的检测方法不仅可以较好地检测Type 1和Type 2克隆，还可以以不同的程度支持Type 3和Type 4克隆的检测。但因其复杂度相对较高，使其并没有太多的检测工具可以利用。基于Metric的检测方法目前仅有一些检测方法被提出[43,44]，缺少相应的检测工具。
可见，目前克隆检测方法对Type 1和Type 2克隆的检测最简单，因此效果最好，检测工具也最多；对Type 3克隆的检测相对于前两种有一定的难度，因此效果一般，但也有少量工具支持；对Type 4克隆的检测难度最大，因此效果最差，工具最少。此外，基于Text、基于Token、基于Tree的克隆检测方法实现容易，是目前较为主流的方法，相应的检测工具也较多。基于PDG的克隆检测方法受到图匹配算法复杂性的影响使得这类方法的实现难度较大，因此实用工具不多。而基于Metric的克隆检测因为检测效果不够理想，所以研究较少，也没有可用的检测工具。其次，目前绝大多数的克隆检测工具仅支持单版本的克隆代码检测，无法同时检测多个版本中的克隆代码。少数的克隆检测工具（如iClone）采用了增量式的克隆代码检测方法，即在旧版本克隆检测的基础上对新版本进行克隆代码检测，从而节约了检测时间，提高了检测效率。此外，目前绝大部分的克隆检测工具也没有集成到软件开发环境中，开发人员无法在开发过程中实时地检测和跟踪克隆代码。因此，研究如何提高Type3和Type 4克隆的检测效果，以及如何在软件开发过程中增量式地检测克隆代码，这既是一个难点问题，也是未来的一个研究重点问题。

%表


\BiSubsection{克隆分析}{Related work}
克隆代码分析的主要目的是辅助开发人员理解克隆代码，是目前克隆代码研究中最为活跃的一个分支。为描述和分析克隆代码的演化过程，Kim等人提出克隆家系的概念，并使用克隆模式表示克隆代码在演化过程中的变化规律[5]。克隆家系引发了对克隆演化分析研究的热潮，克隆演化分析是从软件演化的角度来揭示克隆代码的变化规律及其基本特征。早期研究认为克隆代码是一种代码坏味[6]，容易引发软件缺陷，从而使软件难以理解和维护[7,8]。但对克隆代码演化分析的研究使人们逐渐意识到克隆代码并非都是有害的，引发了对克隆评价的研究，例如克隆代码有害性分析等。研究结果表明克隆代码并不都是有害的，有的克隆代码的稳定性更好，复用此类克隆代码不仅不会降低软件质量，还可以提高软件开发的效率[9-11]。事实上，克隆代码的有害性研究一直被研究人员所关注，但直到现在也没有确切的证据表明克隆代码是完全有害的[12-14]。虽然克隆有害性评价分析可以辅助开发人员分析克隆代码对系统产生的不利影响，但无法直接消除克隆代码及其对系统产生的不利影响，而且很多评价方法属于实证研究，带有一定的主观性和片面性，缺少客观的理论依据。此外，为了辅助开发人员更好地理解和维护克隆代码，不仅需要全面客观的克隆评价方法，还需要在克隆可视化分析、可重构性分析、可复用性分析、缺陷分析等方面进行研究。

克隆分析是指使用各种技术手段分析系统中的克隆代码，并挖掘其隐含的特征，旨在帮助软件开发人员更好地理解和维护克隆代码。目前的克隆分析研究主要集中在克隆演化分析、克隆评价分析和克隆可视化分析等方面。

\BiSubsubsection{克隆演化}{Related work}

克隆代码往往存在于软件系统的多个版本中，并随着软件系统进行演化。克隆代码演化分析就是通过分析克隆代码的演化过程，提取克隆代码的演化特征，识别克隆代码的演化规律，从而辅助人们更好地理解和维护克隆代码。克隆演化研究包括克隆演化过程分析和演化特征分析两个方面。演化过程分析即模型化克隆代码的演化过程。演化特征分析是分析克隆代码在演化过程中表现出来的演化特征或演化模式及其对软件质量的影响。
克隆演化过程分析最早是2001年由Antoniol等人提出的，他们使用时间序列描述克隆代码的演化模型[48]，但并未引起人们的重视。2005年，Kim提出了克隆家系模型用于描述克隆代码的演化过程，被认为是迄今为止最好的演化模型，并已成为克隆演化分析的事实标准[5]。其后，人们对克隆家系进行了大量的研究。例如Roy使用函数映射帮助构建克隆家系，并开发了gCad克隆家系提取器，大大提升了构建克隆家系的时间效率[49]。Bakota通过映射不同版本的克隆来分析克隆代码的演化过程，并使用克隆坏味（Clone Smell）帮助分析克隆代码对系统的影响[50]。2009年，Harder对现有的演化模型进行分析[51]，指出通过分析克隆演化特征可以帮助程序开发和维护人员理解和维护克隆代码。
究竟哪些演化特征能真实准确地反映克隆代码的规律？这是克隆演化分析的难点问题。因此目前对克隆演化分析的研究主要集中在研究确定提取克隆代码的哪些特征作为演化特征以及如何提取这些特征。目前，常用的克隆演化特征主要包括克隆寿命、克隆稳定性与一致性变化。
克隆寿命是指克隆代码在系统中的存在时间，即生存期。Kim研究发现克隆代码要比非克隆代码更加稳定，同时寿命也更长[5]；进一步对长寿命的克隆代码进行研究后，发现对克隆代码的修改会使得克隆代码的寿命变短[52]。Krinke通过对比克隆和非克隆代码，也发现克隆代码比非克隆代码的寿命更长[53]。通过对精确克隆和近似克隆的演化分析，发现其在演化过程中所表现出来的共同特点是：尽管克隆代码比率会随着时间而逐渐降低，但克隆代码的存在时间往往都会超过一年[54]。因此，克隆代码会长时间的存在于系统中，在其生存期间克隆代码往往会发生变化，其变化规律与具体的软件系统相关[55]。
相对于克隆寿命而言，克隆稳定性关注的是在克隆代码的生存期内是发生变化的问题。被研究者普遍认可的观点是寿命较长的克隆代码是稳定的[9-11]，不会对系统造成不利的影响，也不会增加系统的维护成本。但是在克隆代码是否比非克隆代码更稳定这个问题上还存在一定的分歧。例如Gode研究发现大部分克隆是稳定的，不会发生变化[56]。而Rahman的研究却发现克隆代码比非克隆代码更容易发生变化，是不稳定的[57]。Mondal给出了更为细致的分析结果，即Type 1、Type 2克隆是不稳定的，Type 3克隆是稳定的；并且发现克隆代码比非克隆代码的变化更分散，Type 3克隆比Type 1和Type 2克隆的变化更分散[58,59]。由此可见，在克隆代码的稳定性特征方面尚未达成共识，仍需要进一步研究。
克隆代码的变化包括一致性变化和不一致性变化。开发人员遗忘一致性变化将会引发相关的软件缺陷，如标识符重命名不一致性缺陷等，因此一致性变化也是克隆演化分析研究中需要关注的特征。 Gode的研究发现发生一致性变化的克隆代码占克隆代码的比例很小[56]。Krinke的研究进一步发现发生一致性变化和不一致性变化的克隆代码比例大约各占一半，并且大部分发生不一致性变化的克隆代码在后续的演化过程中不会继续发生变化[60]。Mondal等人的研究发现发生一致性变化的克隆代码可能会导致延迟传播现象。延迟传播是指某一个克隆片段的变化没有立即传播到其所在的克隆组中，而在间隔一定数量的版本后传播，继续发生一致性变化。研究表明延迟传播在Type 3的克隆中出现的更为频繁，软件开发人员应该重点关注Type 3克隆代码的变化，以避免引入克隆代码相关的软件缺陷[61]。
表2列出了目前对克隆演化特征的研究情况。由表2可以看出，研究者较为关注的克隆演化特征是克隆寿命、克隆稳定性与一致性变化。上述三个特征并不是相互独立的，克隆寿命会受到稳定性和克隆变化的影响，同时克隆稳定性与克隆变化之间存在对立关系。对克隆演化分析的研究大多属于实证研究，往往会较多地依赖于具体被用于实验分析的软件系统，这就导致了不同的研究可能得出不同的结论。例如对克隆稳定性的研究就出现了截然相反的观点。尽管如此，克隆演化特征分析依然可以给开发人员提供有价值的建议。一个普遍的共识是在维护和管理克隆代码的过程中更应关注那些克隆寿命较短、稳定性较差、发生一致性变化的克隆代码。但克隆寿命、克隆稳定性和一致性变化之间究竟存在着怎样的关系，它们对软件质量究竟会产生怎样的影响，还有哪些影响软件质量的克隆代码特征，还有待进一步深入的研究。


\BiSubsubsection{克隆评价特征}{Related work}

克隆评价分析主要是分析克隆代码对系统产生的影响，以便辅助开发人员更好地理解和维护克隆代码。克隆代码是否有害一直是克隆评价关注的一个热点，也是争论的一个焦点问题。因此，克隆评价研究主要是围绕着克隆代码是否有害而展开的，只是在不同阶段，人们对克隆代码的态度有所不同，研究的关注点也因此有所不同而已。
在研究的初始阶段，人们大多倾向于认为克隆代码都是有害的，因而研究的侧重点是克隆代码是否会引发软件缺陷（即克隆代码相关的缺陷分析），以及克隆代码是否会增大系统的维护代价（即克隆代码的维护代价分析）。然而随着对克隆代码研究的深入，人们研究发现虽然克隆代码有时会对软件质量产生一些负面影响，但并不一定都是有害的，从而引发了对克隆代码有害性的讨论（即克隆代码的有害性分析）。因此，克隆评价主要包括克隆相关的缺陷分析、克隆维护代价分析、克隆有害性分析等。
在早期，有人认为克隆代码是一种最刺鼻的代码坏味，是因为它有可能会引发相关缺陷。因此，人们研究的关注点主要集中在克隆代码的缺陷分析上。例如，Juergens等人研究发现克隆代码的不一致性变化会引发相应的软件缺陷，从而降低了软件质量[7]。Gauthier通过对克隆代码进行安全性分析，在开源软件Joomla和Moodle中发现了几个潜在的影响软件质量的安全漏洞和缺陷[62]。但也有另外一些证据表明克隆代码的不一致性变化并不一定会引发缺陷，因此不会对软件质量产生显著的影响。例如，Bettenburg对不一致性变化是否引发缺陷的研究发现，仅有极少数的不一致性变化会引发缺陷[63]。文献[64]的研究则表明Type 3克隆代码中大约有17%的代码含有缺陷，并且Type 3克隆不容易发生不一致性变化。文献[65]通过对缺陷密度的分析发现，面向对象程序中的克隆类含有更少的缺陷，并且Type 3克隆含有的缺陷最少。因此有人将克隆代码研究应用到缺陷检测中，但没有直接证据证明克隆代码与缺陷密切相关[66,67]。因此，克隆缺陷分析并不能直接证明克隆代码是有害的。
除了克隆相关的缺陷分析外，还可以从维护代价的角度去分析克隆代码对软件产生的影响。Harder通过实验发现克隆代码的存在并不会增加缺陷修复的时间，但是缺陷未被修复则可能导致维护代价的增加[68]。Lozano通过研究克隆代码的可变性，也发现克隆代码的存在会增加软件维护的代价[69]。Juergens不仅认为克隆代码会增加维护代价，还提出了一个计算模型来计算克隆维护代价[70]。而Monden的研究则发现包含少量克隆代码的软件模块比不含克隆代码的软件模块更可靠，但含有大量克隆代码的软件模块则正相反，实验表明克隆代码与软件可靠性和维护代价有一定的关联，但这种关联关系并不十分明确[71]。以上维护代价分析的研究表明克隆代码的存在有可能会增加软件的维护代价，但是如何定量地计算克隆代码引起的维护代价仍然是一个尚未解决的问题。
虽然缺陷分析和维护代价分析可用于评价克隆代码对软件产生的影响，但却不能作为评价克隆代码是否有害的直观证据。正因如此，近些年来，研究人员又展开了克隆代码有害性分析的研究。Kapser通过对比11种克隆模式在软件开发和维护过程中的优缺点，并在开源软件Apache和Gnumeric上进行实证研究，发现在Apache中大约有71\%的克隆代码被分类为有益克隆，对系统维护具有积极的影响，是一种合理的存在方式，因此人们应当正视在开发过程中克隆代码的长期存在[12,72]。Kapser通过对Apache Web Server中的克隆代码进行分析，研究发现其中一个子系统中聚集了大量的克隆代码；该子系统的克隆代码增加了系统的功能性，对软件开发过程是有益的[73]。Selim使用风险模型判定克隆代码是否有害，研究结果发现克隆代码并不比非克隆代码具有更高的有害风险[14]。Wang提出利用贝叶斯网络对克隆代码进行有害性预测的方法[74]，该方法可用于辅助开发人员决定是否可以通过复制粘贴的方式引入新的克隆代码。Higo则提出一种提取有问题的克隆代码（有害克隆）的方法，该方法先对程序进行标准化，然后利用检测工具检测克隆代码，最后对检测到的克隆代码进行过滤、合并等操作来提取有问题的克隆代码，在Linux内核2.6.6上的实验结果表明只有少数克隆代码是有问题的克隆代码[75]。Hordijk提出了一个结构化的证据模型分析克隆代码的有害性，研究结果表明只有少部分的证据证明克隆代码是有害的，并且仍需更多的研究去支撑这一结论[76]。从上述对克隆代码有害性分析的结果不难得出结论，克隆代码并非都是有害的，但是究竟具有什么特征的克隆代码是有害的，还是一个有待深入研究的问题。
表3对克隆评价分析研究进行了分类统计，使用"积极"、"中立"和"消极"三种评价标准对现有的克隆评价分析方法进行了总结。"积极"是指克隆代码的存在对系统有积极的影响；"中立"是指克隆代码不会对系统产生影响；"消极"是指克隆代码会对系统产生消极的影响。从表3可以看出，大部分研究对克隆代码持积极和中立的态度，仅有少数持消极态度。这从另外一个侧面表明目前对克隆代码是否有害还存在一定的分歧，主要原因是对克隆代码缺少统一的评价标准以及深入的特征挖掘与分析，当然这也是克隆评价分析中的最具挑战性的问题。

\BiSubsection{克隆维护和管理}{Related work}

克隆代码的可重构性分析和可复用性分析的直接目标就是克隆维护，例如使用重构方法消除系统中有害的并适合重构的克隆代码[15,16]、复用已有的有益的、可复用的克隆代码等[17,18]。但由于重构条件十分苛刻导致大部分克隆不适合重构，因此重构无法完全消除克隆代码。因克隆代码有害与有益的标准难以确定等原因给可复用性分析带来的困难，也使得克隆复用研究进展较为缓慢。为彻底解决克隆代码维护困难的问题，近几年研究人员开始将研究重点转移到克隆管理上[19,20]。克隆管理试图从管理的角度将相关的克隆研究统一为一个整体，并与软件开发过程相结合，在开发过程中高效地实现对克隆代码的组织、维护和管理。克隆管理不仅有助于消除有害克隆代码及其对系统的不利影响，提高软件的可维护性和可理解性；还有助于复用有益的克隆代码，从而提高软件开发效率。克隆管理作为一个崭新的研究内容，已引起学术界和工业界的广泛关注，但目前克隆管理研究还处于起步阶段，缺少有效且完善的克隆管理方法。

克隆维护是解决克隆代码问题的直接途径，主动地解决克隆代码可能或已经引发的问题。克隆维护与软件开发过程结合得较为紧密，维护的方法主要包括克隆重构、克隆规避、克隆复用。

\BiSubsubsection{克隆维护}{Related work}
重构作为一种常见的软件维护手段，是指在不改变软件外部行为的条件下改变软件的既有设计[6]。重构经常应用于克隆维护中，通过重构手段消除系统中的克隆代码。
由于重构所需的条件较为苛刻，同时重构的代价也较大，还需考虑重构安全的问题。因此，在重构前对克隆代码进行可重构性分析和重构排序显得尤为重要。可重构性分析旨在识别适于重构的克隆代码候选集合，以提高克隆重构的效率。Lin等人通过对克隆代码进行差异性分析，帮助开发人员决定是否进行重构操作和如何执行重构操作[89]。Mende实现了一个工具支持可重构性分析，在软件中识别可以被重构的函数克隆[90]；Schulze提出了一个用于识别可重构的克隆代码的克隆分类方法，通过计算克隆代码的可重构指数识别可重构的克隆代码[91]；Choi等人提出了基于度量值的可重构性分析方法，可以快速地识别可重构的克隆代码[92]。识别可重构克隆后，为了节省重构时间，还可以对克隆代码进行重构排序或者调度。如Mandal先通过分析克隆演化模式来确定克隆候选，然后使用关联规则挖掘进行可重构排序[93,94]；Lee采用遗传算法对重构进行调度，以确定重构顺序帮助改进软件质量[95]；Zibran提出一种极限编程方法对克隆代码进行重构调度[96]。另外，Liu等人提出了一个重构调度方法帮助优化调度过程[97]。尽管该方法不是针对克隆重构的，但也可以考虑将其应用于克隆代码的重构调度上。此外，Radhika等人仅考虑重构代价对所有的克隆代码进行重构排序，未考虑克隆代码是否适合重构的问题[98]，应该结合可重构性分析指导克隆重构。
克隆重构最主要的目的是消除系统中的克隆代码。Higo等人开发了一个工具ARIES，根据克隆代码的结构信息识别可重构的克隆代码，然后通过计算不同的度量值来确定使用哪一种目前已有的重构方法移除克隆代码[15]。Krishnan通过分析克隆代码的程序依赖图，确定给定克隆代码能否被安全的重构，然后通过检测和参数化克隆代码的差异点对克隆代码进行重构，取得了较好的效果[16]。Barbosa使用四种规则重构克隆代码，并在开源软件JhotDraw上进行了实验，结果表明基于规则的重构方法可以有效地移除软件中的克隆代码[99]。
在重构完成后，对重构后代码进行分析，还可以得出一些结论以进一步指导克隆重构。Gde通过对维护人员使用的重构方法和被重构的克隆代码进行实证研究，发现在不同的软件系统中都存在克隆重构的行为，并且克隆重构不是经常性地发生而是有选择性地发生[100]。Zibran等人通过克隆重构研究，回答了所提出的关于克隆重构的七个研究问题，并且研究发现克隆规模对克隆重构没有重要的影响，同时在软件早期的版本中重构会较为频繁地发生，发生重构的克隆在重构前往往是较为稳定的克隆代码[101]。Choi通过对重构行为进行观测，识别出几种较为频繁的克隆重构模式，并且分析了每种重构模式的特征，这些都有助于进一步指导克隆代码的重构[102]。Tairas通过对克隆代码的重构性分析，提出了子克隆的概念，并研究发现子克隆的重构行为更容易发生，因此建议在对克隆代码的维护过程中应重点考虑子克隆的重构[103]。
目前，虽然已有重构方法以插件的形式集成到了eclipse中 ，支持在软件开发过程对一般代码坏味重构。由于一般代码坏味的重构方法不一定适合克隆代重构，所以尚未有在软件开发环境中针对克隆代码的重构方法。此外，重构是在克隆代码出现后用以消除克隆代码的一种被动的软件维护方法，而且并非所有的克隆代码都适合重构，因此重构不是解决克隆代码维护难题的最有效的方法，更有效的方法是在软件开发过程中主动地规避或维护克隆代码，这是克隆维护中的一个难点问题。


\BiSubsubsection{克隆管理}{Related work}

克隆代码管理的主要目的是降低克隆代码维护的代价。目前克隆管理的研究内容主要包括克隆跟踪、克隆变化管理以及克隆管理工具。其中，克隆跟踪是研究跟踪克隆代码产生和变化的方法。克隆变化管理是研究对克隆代码的变化进行管理的方法。克隆管理工具是研究开发有效管理克隆代码的工具。
克隆管理需要解决的首要问题是如何实时地跟踪系统中的克隆代码，包括克隆代码的产生及其变化。由于复制粘贴操作是导致克隆产生的主要原因，因此对克隆跟踪的研究主要是通过监测程序员的复制粘贴操作来实现的。例如，许多克隆跟踪工具CLONEBOARD[120]、CnP[121]、CPC[122]、CReN[123]、CSeR[124]等都是在软件集成开发环境中跟踪克隆代码的产生，但并非都能跟踪克隆代码的变化。另一方面，在软件开发过程中克隆代码可能随时发生变化，因此要实现对克隆代码的管理，不仅要跟踪克隆代码的产生，还要跟踪克隆代码的变化。Duala使用克隆区域描述符描述生成克隆代码的上下文信息，然后根据这些上下文信息实时跟踪克隆代码的变化[30]。该方法仅通过实验验证可以跟踪克隆代码的变化，但是并没有实现可用的插件集成到集成开发环境中，以实现对克隆代码的边开发、边管理。
跟踪克隆代码的目的是为了对克隆代码进行维护和管理。为了实现边开发、边管理克隆代码，还要对克隆代码的变化进行维护和管理。Yamanaka等人[125]将克隆变化与事件通知机制相结合，将每一个克隆变化都看成一个事件，在克隆发生变化时提醒开发人员及时地对克隆变化进行维护。Cheng等人[126]提出了一个基于Token的克隆代码一致性维护方法，当克隆组内的一个代码发生变化时，能够同时修改组内的其他克隆代码，保证克隆代码的一致性。该方法的前提是已知克隆变化需要一致性维护，但没有给出克隆变化是否需要一致性维护的判定方法。因此，Zhang等人[127]在克隆代码发生变化时预测克隆代码一致性维护需求。该方法通过提取克隆代码的演化信息及其相关特征，在克隆代码发生变化时辅助开发人员确定克隆变化是否需要一致性维护。Mondal等人通过对克隆组内的克隆代码排序，从而预测需要一致性维护的克隆代码[128]。此外，Murakami等人在克隆代码未发生变化时，预测克隆代码的下一次变化[129]。该方法通过分析历史版本中的克隆代码的变化情况，提取相关的特征进行变化预测，以便在软件开发过程中提醒开发人员对有可能发生变化的克隆代码进行维护。可见，克隆变化管理的关键不仅需要实时跟踪克隆代码的变化，更重要的是对发生变化的克隆代码进行及时的维护。
前面的研究只是针对不同的侧重点提出的克隆管理方法，却没有提供可以实际应用的克隆管理工具。鉴于此，Zhang基于事件通知机制实现了一个克隆管理工具，不仅可以监测克隆代码的产生，还可以监测克隆代码的维护过程[130]。Nguyen实现了一种可用于管理克隆代码的eclipse插件JSync[131]。该插件支持在软件开发过程中对克隆代码进行克隆关系管理和一致性维护管理。这里的克隆关系管理是指在软件开发过程中检测系统中的克隆代码，并对具有克隆关系的代码进行管理。这里的一致性维护管理是指识别变化的克隆代码以及变化的克隆代码是否会导致不一致性缺陷，以便开发人员对克隆代码进行一致性维护。而另一个较早提出的eclipse插件CeDAR[132]虽然没有强调是一种克隆管理工具，但事实上也具有一定的克隆管理功能。该插件将克隆检测和克隆重构融为一体，对现有克隆检测工具的克隆检测结果进行可重构性分析，寻找潜在的可重构的克隆代码，然后在软件开发过程中实现对克隆代码的重构。
如何将克隆代码的检测、分析和维护结合到软件开发过程中，以实现对克隆代码的边开发、边维护和边管理是克隆管理急需解决的一个难点问题


\BiSection{拟解决的关键科学问题}{The problem and its complexity}
研究问题：本课题通过结合软件演化、机器学习、程序分析方法，如何提取克隆演化中所隐含的信息，即克隆演化特征？ 针对变化的克隆代码，如何对其进行一致性需求维护预测，识别出需要关注的克隆代码及其变化？对需要一致性维护的发生变化的克隆代码，如何提供一致性维护支持方法，自动地维护克隆代码的一致性？\\

子问题1：克隆代码随着系统的演化而演化，在克隆代码及其演化过程中必然隐含了一定的规律和信息，如何揭示隐藏在克隆代码及其演化过程中的克隆代码特征，帮助软件开发和维护人员充分理解和分析克隆代码？ \\

在软件中存在大量克隆代码，我们使用当前的克隆检测工具可以检测系统中大量克隆代码。尽管我们可以检测克隆代码，但是这些克隆代码是否隐藏了一些信息，如何获取这些信息是值得研究的一个问题。同时，克隆代码并不是静态的，是随着软件系统演化而演化。目前对于克隆代码的演化过程和演化模式也有比较深入的研究，但是对克隆演化的研究都集中在克隆演化过程和克隆模式上，演化过程和演化模式中是否存在特定的结论，我们称其为克隆演化特征。克隆代码演化特征是在克隆代码及其演化过程中，所包含或所隐藏的有助于理解和维护克隆代码的一些指导性结论。因此，如何结合克隆演化过程和克隆演化模式，揭示软件中的克隆演化特征，并用于指导克隆代码维护是一个值得研究的问题。\\

子问题2：如何在复制和粘贴之时快速有效的识别出系统中的可能需要一致性维护的克隆代码，并在复制粘贴之时避免此类克隆代码的产生或者复用不需要维护的克隆代码，从而帮助降低软件的维护代价？\\

系统中存在大量的克隆代码，并且克隆也随系统演化而演化。在这些克隆代码中，存在相当数量的经常发生变化的克隆代码，尤其是发生一致性变化的克隆代码。克隆代码的一致性变化会对软件产生深远的影响，如会引发额外的维护代价，于此同时遗忘这种变化会引入额外的维护代价。因此，如何在克隆代码产生之时即复制粘贴时，预测此克隆代码在未来演化中是否会发生一致性变化是值得研究的问题。即在复制粘贴时预测克隆代码的一致性维护需求仍是一个值得研究问题。在复制粘贴之时预测该克隆代码的一致性维护需求，可以用于克隆代码的预防和避免中。如果其需要一致性维护需求，则不允许该克隆代码的产生，从而可以减少克隆代码导致的维护代价，也可以避免一致性缺陷。同时，在复制粘贴之时预测该克隆代码的一致性维护需求，还可以用于帮助快速开发软件系统，保证软件质量。如果其不需要一致性维护需求，则程序开发人员可以放心大胆的复用该克隆代码，可以提高软件开发速度，同时因为不需要一致性维护也可以提高代码质量。\\

子问题3：如何在克隆代码发生变化之时，快速有效的预测同组克隆代码是否同时需要发生一致性变化，并在发生变化时提示维护人员对克隆代码进行一致性维护，从而避免引入与之相关的一致性缺陷？\\

系统中存在大量的克隆代码，并且克隆也随系统演化而演化。在这些克隆代码中，存在相当数量的经常发生变化的克隆代码，尤其是发生一致性变化的克隆代码。克隆代码的一致性变化会对软件产生深远的影响，如会引发额外的维护代价，于此同时遗忘这种变化会引入额外的维护代价。因此，如何在克隆代码发生变化之时，预测同组的克隆代码在未来演化中是否会发生一致性变化是值得研究的问题。即在克隆代码变化之时预测同组克隆代码的一致性维护需求是一个值得研究问题。当克隆代码发生变化时，往往同时需要确认同组的克隆代码中是否需要同样的变化，即一致性变化。确认这种变化需求会增加软件的维护代价，维护人员需要花费大量的时间对其进行分析。同时，对于需要一致性维护的克隆代码，遗忘这种一致性维护会直接导致一致性缺陷的产生，将大大降低软件质量，进一步增加软件的维护代价。\\

子问题4：在克隆代码发生变化后，对于需要一致性变化的克隆代码，如何有效地帮助维护人员维护克隆代码的一致性，自动维护发生变化的克隆代码，从而提高软件的可维护性并降低引入一致性缺陷的可能性？\\

系统中存在大量的克隆代码，并且克隆也随系统演化而演化。在这些克隆代码中，大部分的克隆代码是静止不变的。但同时存在相当数量的经常发生变化的克隆代码，尤其是发生一致性变化的克隆代码。克隆代码的一致性变化会引发额外的维护代价，维护人员需要对同组的克隆代码进行反复确认所发生的变化，同时还要主动且人工的对其进行一致性的维护。这一过程会花费维护人员的大量时间，与此同时人工的确认和维护还容易引发更多的缺陷，将会进一步的导致维护代价的增大。因此，如何在克隆代码发生变化之时，对需要一致性的克隆代码，对其进行自动地一致性变化维护是值得研究的问题。即在克隆代码变化之时对同组克隆代码进行一致性维护是一个值得研究问题。自动地对发生变化的克隆代码进行一致性维护，可以大大地降低软件的维护代价，并同时可以减少一致性缺陷的引入。同时，该方法可以切实的与软件开发环境相结合，在开发过程中实现对克隆代码的维护。



\BiSection{主要工作与论文结构}{Main research contents and structure of this dissertation}

\BiSubsection{主要内容}{Main research contents}

克隆代码随着软件系统的演化同时演化，在其演化过程中所表现出的特征称之为克隆演化特征。克隆演化特征对理解和维护克隆代码有极为重要的意义，本文结合机器学习方法，提取相应的度量值对克隆代码进行演化特征分析。在演化过程中，克隆代码的一致性维护问题是影响软件质量的一个重要因素，因此进而研究克隆代码的一致性维护需求。在克隆代码产生和变化之时，分别对其进行一致性维护需求预测，从而避免引入和克隆代码相关的额外维护代价。克隆代码的一致性变化深深影响着软件质量，对克隆代码的一致性变化提供支持，实现克隆代码的一致性维护，可以帮助维护克隆代码，避免引入由于变化导致的克隆一致性缺陷。论文通过对克隆代码的演化特征分析，发现克隆代码一致性问题是影响软件质量原因。通过在复制粘贴和代码变化之时预测克隆代码的一致性维护需求，帮助避免克隆所产生的额外维护代价。通过对克隆代码的一致性维护实现对克隆代码变化的自动维护，提高系统的可维护性和软件质量。
(1) 研究基于聚类分析的克隆代码演化特征提取方法
a) 研究基于演化的克隆静态和演化度量提取与优选；
b) 研究基于聚类的克隆演化特征提取。
(2) 研究基于复制粘贴的克隆代码一致性维护需求预测方法
a) 研究基于复制粘贴的克隆代码度量提取与优选；
b) 研究基于机器学习的克隆代码一致性维护需求预测。
(3) 研究基于贝叶斯网络的克隆代码一致性变化预测方法
a) 研究基于演化的克隆静态和动态度量提取与优选；
b) 研究基于贝叶斯网络的克隆代码一致性变化预测；
(4) 研究基于代码静态分析的克隆代码一致性维护方法
a) 研究基于代码静态分析的代码差异性分析。
b) 研究基于程序分析的克隆代码一致性维护。

\begin{figure}[htbp]
\centering
\includegraphics[width = 0.4\textwidth]{Fig1-1framework.pdf}
\bicaption[golfer1]{}{打高尔夫球的人}{Fig.$\!$}{The person playing golf}\vspace{-1em}
\end{figure}


为了进一步说明本文的研究内容以及各个部分之间的关系，本文给出本文主要研究内容如图所示。本文包含四个研究内容：基于聚类的克隆代码演化特征分析研究、基于演化特征与机器学习的克隆代码评价研究、基于演化特征克隆代码可视化研究、基于演化特征与评价的克隆代码维护研究。首先，基于聚类的克隆代码演化特征分析研究是本文的基础，通过聚类分析克隆代码，获得克隆代码演化特征的一般性结论，结论可以帮助理解克隆代码并指导后续的克隆评价和克隆可视化的研究。然后，基于演化特征与机器学习的克隆代码评价研究，在聚类分析的结论的基础上，对克隆代码进行评价，提取重要克隆代码，并评价克隆代码的有害性和有益性，进一步分析克隆代码，评价结果可以直接作为克隆代码为的输入，帮助维护克隆代码。同时，基于演化特征克隆代码可视化研究，根据克隆演化情况和克隆评价结果，对克隆代码进行可视化分析，可视化克隆代码的基本信息和克隆评价结果，帮助理解和维护克隆代码。然后，基于演化特征与可视化的克隆代码维护研究，在克隆演化、克隆评价和克隆可视化额基础上，对克隆代码进行维护操作，实现对克隆代码克隆模式和缺陷维护、克隆重构和复用维护，从而消除克隆代码的不利影响。

\BiSubsection{论文结构}{Structure of this dissertation}

研究基于演化分析与机器学习的克隆代码分析方法
研究基于演化分析和机器学习的克隆代码分析方法，将多种检测工具检测得到的克隆代码统一表示和组织，并在提取和分析克隆代码及其演化特征的基础上，采用机器学习的方法识别重要的克隆代码，评价其有害性和有益性，对系统中存在的克隆代码及其分析和评价结果进行可视化，辅助维护人员更好地理解克隆代码。
具体研究内容：
1)	研究基于聚类的克隆代码演化特征分析方法；
2)	研究基于演化特征和机器学习的克隆代码评价方法；
3)	研究基于演化分析的克隆分析和评价可视化方法。
4.2.1克隆表示与组织方法
将研究基于演化和特征分析的克隆代码表示和组织方法，克隆代码表示与组织是指将克隆代码用统一的形式组织和表示起来，方便克隆代码的查询，主要包含克隆代码的表示和克隆代码组织。克隆表示是使用一种统一的形式表示克隆代码；克隆代码组织是有效地组织克隆代码。同时可以在此基础上实现对克隆代码的分析、维护和管理。
4.2.2研究基于聚类的克隆代码演化特征分析
本文将研究基于聚类的克隆代码演化特征分析方法，克隆代码演化特征是在克隆代码及其演化过程中，所包含或所隐藏的有助于理解和维护克隆代码的一些指导性结论。本文将使用机器学习方法对克隆代码、克隆组和克隆家系进行聚类，并根据聚类结果分析克隆演化特征，帮助理解克隆代码并指导克隆代码维护。基于聚类的克隆代码演化特征分析研究包含两个子任务：
（1）研究基于演化的克隆静态和演化度量提取与优选方法；
本文为了表示克隆代码信息，也为了更方便对克隆代码进行聚类，本文使用克隆度量表示克隆代码及其演化过程，提取了克隆代码度量值（静态度量和演化度量），根据实验结果并对克隆代码度量进行优选是克隆度量更好地表征克隆代码和演化过程。静态度量是指仅通过单一版本的分析即可提取的克隆代码特征，演化度量表示了克隆代码在演化过程中的变化情况。
（2）研究基于聚类的克隆代码演化特征提取方法
不同粒度的克隆代码及其演化过程会隐藏不同克隆演化特征，因此对克隆代码的演化特征提取将分成这三个粒度进行：克隆代码片段、克隆组以及克隆家系。对克隆片段聚类是将每个单独的克隆代码作为一个个体进行聚类；对克隆组聚类是对所有克隆组进行聚类；对克隆家系将对系统中所有克隆的演化过程等聚类分析。
4.2.3 研究演化特征和机器学习的克隆代码评价方法
本文将研究基于演化特征和机器学习的克隆代码评价方法，在分析得出克隆演化特征的基础上，选用合适的机器学习模型识别重要的克隆代码，对克隆代码进行评价，评价其有害性和有益性，为了更好地评价本文将从基于克隆演化特征提取适用于机器学习模型的克隆度量（静态度量和演化度量），并根据结果实现对克隆度量的优选，从而可以帮助维护人员理解克隆代码，提高系统可维护性。基于演化特征和机器学习的克隆代码评价方法包括以下：
（1）研究基于演化特征的静态和演化度量提取与优选方法
本文为了方便使用机器学习模型对克隆代码进行评价，同时也为了更好地利用克隆演化特征帮助评价克隆代码，本文将提取可以表示克隆代码及其演化特征的度量值（静态度量和演化度量），并可以根据结果对克隆度量进行优选。其中，静态度量是指仅通过单一版本的分析即可提取的克隆代码特征，演化度量表示了克隆代码在演化过程中的变化情况。
(2)研究基于机器学习的重要克隆代码识别

（3）研究基于机器学习的重要克隆代码有害性分析方法
本文基于演化特征和机器学习的克隆代码评价方法包括评价克隆代码的有害性和有益性两个方面。评价克隆代码的有害性立足于部分克隆代码是有害的，会对软件造成威胁（引入缺陷）和导致额外的维护代价，将分析克隆缺陷与克隆维护代价；评价克隆代码有益性立足于部分克隆代码对软件系统是有益的，会提高软件的健壮性和可复用性，将分析克隆可重构性和克隆可复用性。
4.2.4 研究基于演化特征的克隆代码可视化方法
研究基于演化特征和评价的克隆代码可视化方法，将软件克隆信息直观的展示出来，可以从整体上把握软件克隆信息，主要包含克隆特征可视化和克隆评价可视化，可以帮助维护人员理解克隆代码。克隆代码的克隆特征可视化是基于克隆特征分析的，将特征分析结果直观的显示给维护人员帮助理解和维护克隆代码，即可视化当前系统的克隆代码情况，包括克隆统计信息可视化和克隆演化可视化。克隆统计信息的可视化包含基本信息可视化和空间分布可视化，要显示其分布位置、分布密度、规模统计直方图等。克隆演化可视化是对克隆代码的演化过程进行可视化，可视化其克隆家系、可视化克隆模式等等。克隆代码的克隆评价可视化是基于克隆评价结果的，将克隆评价结果直观的显示给维护人员帮助理解和维护克隆代码，即可视化对当前系统克隆代码评价结果，包括克隆有害性可视化和克隆有益性可视化，将具备同一类特征的克隆展示出来，并结合克隆缺陷、维护代价、重构与复用对其可视化分析。
本文将研究基于演化特征和评价的克隆代码可视化方法，将对克隆代码的直观显示，将软件克隆信息直观的展示出来，可以从整体上把握软件克隆信息，主要包含克隆特征可视化和克隆评价可视化，可以帮助维护人员理解和维护克隆代码。
（1）研究演化特征的克隆可视化方法
克隆代码的克隆特征可视化是基于克隆特征分析的，将特征分析结果直观的显示给维护人员帮助理解和维护克隆代码，即可视化当前系统的克隆代码情况，包括克隆统计信息可视化和克隆演化可视化。克隆统计信息的可视化包含基本信息可视化和空间分布可视化，要显示其分布位置、分布密度、规模统计直方图等。克隆演化可视化是对克隆代码的演化过程进行可视化，可视化其克隆家系、可视化克隆模式等等。
（2）研究克隆评价的克隆可视化方法
克隆代码的克隆评价可视化是基于克隆评价结果的，将克隆评价结果直观的显示给维护人员帮助理解和维护克隆代码，即可视化对当前系统克隆代码评价结果，包括克隆有害性可视化和克隆有益性可视化，将具备同一类特征的克隆展示出来，并结合克隆缺陷、维护代价、重构与复用对其可视化分析。
4.3 面向软件开发过程的克隆维护方法研究
研究面向软件开发过程的克隆代码维护方法，将克隆代码的维护结合到软件开发过程中，在软件开发的同时维护克隆代码。首先，在软件维护阶段，研究面向软件维护阶段的克隆代码维护方法，对有害克隆和有益克隆采用不同的维护方法，实现对克隆代码的缺陷维护和复用维护。然后，在软件编码阶段，研究面向软件编码阶段的克隆代码实时维护，通过监测软件开发过程中开发人员的复制粘贴操作以及克隆代码变化情况，对有可能引发缺陷的克隆代码给出预警，对分析识别出的有益克隆实现克隆可视化查询和复用功能，减少软件开发时间，提高编码效率，从而实现边开发边维护克隆代码，以降低软件开发和维护的成本。
1)	研究面向软件维护阶段的克隆代码维护方法
2)	研究面向软件编码阶段的克隆代码实时维护方法
4.3.1研究面向软件维护阶段的克隆代码维护方法
在软件维护阶段，根据克隆演化特征和克隆评价结果对克隆代码进行维护操作。对于有害克隆，有害克隆往往是导致缺陷的最重要原因，因此将分析有害克隆的特征，识别其克隆模式，检测相关缺陷并修复克隆导致的缺陷；对于有益克隆，有益克隆往往是质量较高的代码，复用此类代码会提高软件质量，因此根据重构条件重构并复用有益的克隆代码。包括两个自内容：
（1）对克隆代码有害性评价可以识别有害的克隆代码，而有害的克隆代码往往和克隆模式相关，揭示了克隆的演化过程，克隆模式相关缺陷也是危害软件质量的重要原因。本文的克隆模式与缺陷维护方法将对克隆代码和克隆模式进行缺陷分析，对可能或者已经引发缺陷进行缺陷识别与预测，并修复已发现的缺陷，分析缺陷产生原因。
（2）对克隆代码有益性评价可以识别有益的克隆代码，对有益的克隆代码对其执行克隆重构对其复用。本文的克隆代码重构与复用维护包括可重构分析识别可重构的克隆代码，对适合重构的克隆代码进行重构代价分析，并给出重构建议和复用。对不可重构的克隆候选，对其进行克隆管理评注进行维护。
4.3.2研究面向软件编码阶段的克隆代码实时维护方法
在软件编码阶段，通过监视跟踪复制粘贴活动避免克隆代码的产生，并对无法避免的克隆代码进行缺陷预测和一致性变化预测，避免克隆代码导致软件缺陷。同时，监测文件变化和克隆代码的变化，避免由于变化而导致的缺陷产生。然后，实现克隆查询和复用功能，减少软件开发时间，提高编码效率。
（1）	基于跟踪复制粘贴活动的克隆避免与产生维护
复制粘贴活动是导致克隆代码产生的最要原因，要避免
（2）	基于文件变化的克隆变化维护
对于新产生的克隆代码进行缺陷预测与一致性变化预测
对于变化的克隆进行一致性变化预测与分析
（3）	基于克隆查询的克隆代码复用管理


本文提出基于演化分析和机器学习的克隆代码分析与维护方法，将综合考虑克隆代码演化、克隆度量、机器学习方法和软件开发过程等，将克隆检测、克隆分析和与克隆维护统一为一个有机整体，并充分考虑软件开发过程，在软件开发过程中实现对克隆代码的化特征分析、克隆评价分析、克隆可视化分析以及克隆代码维护。通过对克隆代码进行聚类分析获得克隆演化特征的一般性结论，并在此基础上使用机器学习方法提取重要克隆代码，并评价克隆代码的有害性和有益性，对克隆代码进行可视化分析，能够可视化克隆代码的基本信息以及评价结果，帮助维护人员理解和维护克隆代码，结合克隆分析与软件开发过程实现克隆代码的维护，在软件维护阶段完成对有害克隆的缺陷维护和有益克隆的复用维护，在软件编码阶段实现对克隆产生和变化的实时维护。

图1 基于演化分析与机器学习的克隆分析与维护研究

基于演化的克隆代码分析和维护方法，在检测克隆代码的基础上，对克隆代码进行分析（演化特征分析、评价分析和可视化分析），从而帮助维护人员更好地理解克隆代码，并在分析的基础上对克隆代码进行维护，从而消除有害克隆和复用有益克隆。首先，基于聚类的克隆代码演化特征分析研究。使用模糊聚类方法对克隆代码片段、克隆组和克隆家系分别进行聚类，分析出克隆代码隐含信息，根据结果分析得出相关指导性结论。然后，基于演化特征与机器学习的克隆代码评价研究。对克隆代码进行评价分析，（即基于机器学习的克隆代码评价），主要评价克隆代码的有害性和有益性。然后，基于演化特性的克隆代码可视化研究。针对克隆基本信息、克隆演化和克隆评价结果进行克隆代码的可视化。最后，基于演化特征与可视化的克隆代码维护。基于克隆分析的结果对克隆代码进行维护，包含对克隆代码的克隆模式和缺陷维护、克隆代码重构和复用维护。这几个方面彼此之间不是孤立的，而是至上而下紧密结合的，克隆聚类分析得出一般性结论，克隆评价分析得出具体可操作的结论，克隆可视化实现对分析的，最后克隆维护实现解决分析的问题。本文的研究成果有望真正应用于大型软件的维护，提高软件质量，因此具有重要的理论研究意义与实际应用价值。

项目研究的预期目标
面向越来越多的领域软件越来越复杂，在演化过程中产生的克隆代码越来越多的背景，本项目针对克隆代码会导致软件系统难于维护、软件质量下降等问题，将克隆分析和克隆维护相结合提出基于演化的克隆代码分析和维护方法，以达到可以评价克隆代码有害性，并可视化评价结果，最终达到维护克隆代码的目的，从而增强软件的可维护性和可理解性、提高软件质量。具体目标如下：
（1）能够实现克隆代码的演化特征提取，分析克隆在演化过程中的隐含信息，从而为下一步克隆代码评价做好基础。
（2）能够在获取演化特征的基础上实现克隆代码的评价，提取出重要的克隆代码，并评价克隆代码的有害性和有益性。
（3）能够在克隆特征和克隆评价的基础上实现克隆代码可视化，可视化克隆特征和可视化克隆评价结果。
（4）能够结合软件开发过程和克隆代码分析，实现在软件开发过程中实现对克隆代码的维护，完成并实现对克隆代码的克隆模式与缺陷维护，完成并实现克隆代码重构与复用维护。


